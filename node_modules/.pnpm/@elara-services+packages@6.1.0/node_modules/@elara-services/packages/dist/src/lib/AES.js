"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AES = void 0;
const utils_1 = require("@elara-services/utils");
const crypto_1 = require("crypto");
const package_json_1 = require("../../package.json");
const header = `[${package_json_1.name}, v${package_json_1.version}]: [AES]`;
class AES {
    constructor(key) {
        if (!utils_1.is.string(key)) {
            throw new Error(`${header} You didn't include a key in the constructor.`);
        }
        this.key = key;
    }
    encrypt(input) {
        const isString = utils_1.is.string(input);
        const isBuffer = Buffer.isBuffer(input);
        if (!(isString || isBuffer) ||
            (isString && !input) ||
            (isBuffer && !Buffer.byteLength(input))) {
            throw new Error(`${header} Provided invalid 'input', must be a non-empty string or buffer.`);
        }
        const sha = (0, crypto_1.createHash)("sha256");
        sha.update(this.key);
        const iv = (0, crypto_1.randomBytes)(16);
        const cipher = (0, crypto_1.createCipheriv)("aes-256-ctr", sha.digest(), iv);
        let buffer = input;
        if (isString) {
            buffer = Buffer.from(input);
        }
        const text = cipher.update(buffer);
        let encrypted = Buffer.concat([
            iv,
            text,
            cipher.final(),
        ]);
        if (isString) {
            encrypted = encrypted.toString("base64");
        }
        return encrypted;
    }
    decrypt(encrypted) {
        const isString = utils_1.is.string(encrypted);
        const isBuffer = Buffer.isBuffer(encrypted);
        if (!(isString || isBuffer) ||
            (isString && !encrypted) ||
            (isBuffer && !Buffer.byteLength(encrypted))) {
            throw new Error(`${header} Provided "encrypted" must be a non-empty string or buffer`);
        }
        const sha256 = (0, crypto_1.createHash)("sha256");
        sha256.update(this.key);
        let input = encrypted;
        if (isString) {
            // @ts-expect-error
            input = Buffer.from(encrypted, "base64");
            if (input.length < 17) {
                throw new Error(`${header} Provided "encrypted" must decrypt to a non-empty string or buffer`);
            }
        }
        else {
            if (Buffer.byteLength(encrypted) < 17) {
                throw new Error(`${header} Provided "encrypted" must decrypt to a non-empty string or buffer`);
            }
        }
        const decipher = (0, crypto_1.createDecipheriv)("aes-256-ctr", sha256.digest(), input.slice(0, 16));
        const ciphertext = input.slice(16);
        let output;
        if (isString) {
            // @ts-expect-error
            output = decipher.update(ciphertext) + decipher.final();
        }
        else {
            output = Buffer.concat([
                // @ts-expect-error
                decipher.update(ciphertext),
                decipher.final(),
            ]);
        }
        return output;
    }
}
exports.AES = AES;
