"use strict";
var _API_instances, _API_agents, _API_debug, _API_getDefaultService, _API_getStr, _API_getPostInfoFromURL;
Object.defineProperty(exports, "__esModule", { value: true });
exports.API = void 0;
const tslib_1 = require("tslib");
const api_1 = require("@atproto/api");
const utils_1 = require("@elara-services/utils");
const package_json_1 = require("../../package.json");
const utils_2 = require("../utils");
class API {
    constructor(options) {
        _API_instances.add(this);
        this.options = options;
        _API_agents.set(this, new Map());
        _API_debug.set(this, false);
        if (utils_1.is.boolean(options.debug)) {
            tslib_1.__classPrivateFieldSet(this, _API_debug, options.debug, "f");
        }
    }
    debug(...args) {
        if (!tslib_1.__classPrivateFieldGet(this, _API_debug, "f")) {
            return;
        }
        (0, utils_1.log)(`[${package_json_1.name}, v${package_json_1.version}]: `, ...args);
    }
    get agents() {
        return {
            add: async (keys) => {
                for (const key of (0, utils_2.transformKeys)(keys)) {
                    if (tslib_1.__classPrivateFieldGet(this, _API_agents, "f").has(tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getStr).call(this, key.username, key.service))) {
                        continue;
                    }
                    await this.agent(key);
                }
                return;
            },
            remove: (name, service) => {
                tslib_1.__classPrivateFieldGet(this, _API_agents, "f").delete(tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getStr).call(this, name, service));
                return this;
            },
            list: () => [...tslib_1.__classPrivateFieldGet(this, _API_agents, "f").values()],
            search: (query, searchType = "find") => {
                const list = this.agents.list();
                if (!utils_1.is.array(list)) {
                    return null;
                }
                const data = list[searchType]((c) => c.session?.handle === query.username ||
                    c.service.href == query.service);
                if (utils_1.is.array(data)) {
                    return data;
                }
                else if (data) {
                    return [data];
                }
                return null;
            },
        };
    }
    async agent(key) {
        if (!key) {
            key = (0, utils_2.getRandomKey)(this.options.keys);
        }
        const k = tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getStr).call(this, key.username, key.service);
        if (tslib_1.__classPrivateFieldGet(this, _API_agents, "f").has(k)) {
            return tslib_1.__classPrivateFieldGet(this, _API_agents, "f").get(k);
        }
        const agent = new api_1.BskyAgent({
            service: key.service || tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getDefaultService).call(this),
        });
        await agent
            .login({ identifier: key.username, password: key.appKey })
            .then((r) => this.debug(`[ACCOUNT:${r.success ? "Connected" : "ERROR"}]: For ${k}`))
            .catch((err) => this.debug(`[ACCOUNT:ERROR] For ${k}`, err));
        tslib_1.__classPrivateFieldGet(this, _API_agents, "f").set(k, agent);
        return agent;
    }
    get users() {
        return {
            fetch: async (name) => {
                const agent = await this.agent();
                const res = await agent
                    .getProfile({ actor: name })
                    .catch(() => ({ success: false, data: null }));
                if (!res.success || !res.data) {
                    return utils_1.status.error(`Unable to fetch (${name})`);
                }
                return utils_1.status.data(res.data);
            },
            fetchMultiple: async (names) => {
                const agent = await this.agent();
                const res = await agent
                    .getProfiles({ actors: names })
                    .catch(() => ({ success: false, data: null }));
                if (!res.success || !res.data) {
                    return utils_1.status.error(`Unable to fetch (${names.join(", ")})`);
                }
                return utils_1.status.data(res.data.profiles);
            },
            posts: {
                fetch: async (username, postId) => {
                    const agent = await this.agent();
                    const res = await agent
                        .getPost({
                        rkey: postId,
                        repo: username,
                    })
                        .catch((e) => {
                        this.debug(`[POSTS:FETCH]: Error`, e);
                        return null;
                    });
                    if (!res) {
                        return utils_1.status.error(`Unable to fetch the post info`);
                    }
                    return utils_1.status.data(res);
                },
                fetchMultiple: async (posts) => {
                    if (!posts.length) {
                        return utils_1.status.error(`You didn't provide any posts to fetch.`);
                    }
                    const res = [];
                    const agent = await this.agent();
                    for await (const post of posts) {
                        const r = await agent
                            .getPost({
                            repo: post.username,
                            rkey: post.postId,
                        })
                            .catch((e) => {
                            this.debug(`[POSTS:FETCH_MULTIPLE]: Error`, e);
                            return null;
                        });
                        if (r && r.cid) {
                            res.push(r);
                        }
                    }
                    if (!res.length) {
                        return utils_1.status.error(`Unable to fetch any post data.`);
                    }
                    return utils_1.status.data(res);
                },
                fetchFromURL: async (url) => {
                    if (!Array.isArray(url)) {
                        url = [url];
                    }
                    if (!url.length) {
                        return utils_1.status.error(`You didn't provide any urls to fetch.`);
                    }
                    const agent = await this.agent();
                    const posts = [];
                    for await (const u of url) {
                        const s = tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getPostInfoFromURL).call(this, u);
                        if (!s) {
                            continue;
                        }
                        const r = await agent
                            .getPost({
                            repo: s.username,
                            rkey: s.postId,
                        })
                            .catch((e) => this.debug(e));
                        if (r && r.cid) {
                            posts.push(r);
                        }
                    }
                    if (!posts.length) {
                        return utils_1.status.error(`Unable to fetch any posts.`);
                    }
                    return utils_1.status.data(posts);
                },
            },
            feeds: {
                fetch: async (name, options) => {
                    const agent = options?.agent || (await this.agent());
                    const res = await agent
                        .getAuthorFeed({
                        actor: name,
                        limit: options?.limit || 100,
                        filter: options?.filter,
                    })
                        .catch(() => ({ success: false, data: null }));
                    if (!res.success || !res.data) {
                        return utils_1.status.error(`Unable to fetch (${name})`);
                    }
                    if (utils_1.is.number(options?.checkAgainstTime)) {
                        const feed = res.data.feed.filter((c) => c.reason?.$type ===
                            "app.bsky.feed.defs#reasonRepost"
                            ? (0, utils_2.checkIfNew)({
                                ...c.reason.by,
                                record: {
                                    createdAt: c.reason.indexedAt,
                                },
                            }, options?.checkAgainstTime || utils_1.get.mins(1))
                            : (0, utils_2.checkIfNew)(c.post, options?.checkAgainstTime || utils_1.get.mins(1)));
                        if (!utils_1.is.array(feed)) {
                            return utils_1.status.error(`Unable to find any new posts.`);
                        }
                        return utils_1.status.data(feed);
                    }
                    return utils_1.status.data(res.data.feed);
                },
                fetchMultiple: async (names, options) => {
                    if (!utils_1.is.object(options)) {
                        options = {};
                    }
                    const agent = options?.agent || (await this.agent());
                    const feeds = new Map();
                    for await (const name of names) {
                        const res = await this.users.feeds.fetch(name, {
                            ...options,
                            agent,
                        });
                        if (res.status) {
                            feeds.set(name, res.data);
                        }
                    }
                    if (!feeds.size) {
                        return utils_1.status.error(`No posts found for (${names.length}) users provided.`);
                    }
                    return utils_1.status.data(feeds);
                },
            },
            likes: {
                get: async (name, limit = 100) => {
                    const agent = await this.agent();
                    const res = await agent
                        .getActorLikes({ actor: name, limit })
                        .catch(() => ({ success: false, data: null }));
                    if (!res.success || !res.data) {
                        return utils_1.status.error(`Unable to fetch (${name})`);
                    }
                    return utils_1.status.data(res.data.feed);
                },
                post: async (cid, uri) => {
                    const agent = await this.agent();
                    const res = await agent.like(uri, cid).catch((e) => e);
                    if (!("cid" in res)) {
                        return utils_1.status.error(res instanceof Error ? res.message : res);
                    }
                    return utils_1.status.data(res);
                },
                likeFromAccounts: async (post, users, shouldRepost) => {
                    if (typeof post === "string") {
                        const r = await this.users.posts.fetchFromURL(post);
                        if (!r.status) {
                            return r;
                        }
                        post = {
                            cid: r.data[0].cid,
                            uri: r.data[0].uri,
                        };
                    }
                    if (!post.cid || !post.uri) {
                        return utils_1.status.error(`You provided an invalid post.cid or post.uri`);
                    }
                    if (!users.length) {
                        return utils_1.status.error(`You didn't provide any users to use.`);
                    }
                    const data = [];
                    let i = 0;
                    for await (const user of users) {
                        if (!user.username || !user.appKey) {
                            continue;
                        }
                        const api = new API({
                            keys: [user],
                            debug: true,
                        });
                        const agent = await api.agent();
                        if (shouldRepost === true) {
                            const repost = await agent
                                .repost(post.uri, post.cid)
                                .catch((e) => this.debug(e));
                            if (repost && repost.cid) {
                                data.push({
                                    repost,
                                });
                            }
                        }
                        const r = await agent
                            .like(post.uri, post.cid)
                            .catch((e) => this.debug(e));
                        if (r && r.cid) {
                            data.push({
                                like: r,
                            });
                        }
                        await (0, utils_1.sleep)(i * 500);
                        i++;
                    }
                    if (!data.length) {
                        return utils_1.status.error(`Unable to like the post on any account.`);
                    }
                    return utils_1.status.data(data);
                },
            },
        };
    }
}
exports.API = API;
_API_agents = new WeakMap(), _API_debug = new WeakMap(), _API_instances = new WeakSet(), _API_getDefaultService = function _API_getDefaultService() {
    return this.options.defaultService || utils_2.baseService;
}, _API_getStr = function _API_getStr(username, service) {
    return `${service || tslib_1.__classPrivateFieldGet(this, _API_instances, "m", _API_getDefaultService).call(this)}|${username}`;
}, _API_getPostInfoFromURL = function _API_getPostInfoFromURL(url) {
    const str = url.split("/profile/")?.[1] || "";
    if (!str) {
        return null;
    }
    const [username, postId] = str.split("/post/");
    if (!username || !postId) {
        return null;
    }
    return {
        username,
        postId,
    };
};
