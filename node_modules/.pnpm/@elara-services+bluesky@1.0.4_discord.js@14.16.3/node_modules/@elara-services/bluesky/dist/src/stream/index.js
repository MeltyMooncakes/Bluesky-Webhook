"use strict";
var _Stream_instances, _Stream_discordBotToken, _Stream_name_get, _Stream_icon_get, _Stream_mins_get, _Stream_handlePost, _Stream_run, _Stream_debug;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@elara-services/utils");
const webhooks_1 = require("@elara-services/webhooks");
const events_1 = require("events");
const package_json_1 = require("../../package.json");
const api_1 = require("../api");
const utils_2 = require("../utils");
const parser_1 = require("../utils/parser");
class Stream extends api_1.API {
    constructor(options, discordBotToken) {
        super(options);
        _Stream_instances.add(this);
        this.options = options;
        this.stream = new events_1.EventEmitter();
        this.cache = new Map();
        /** Only needed for 'channels.channelId' options so the package can send announcements */
        _Stream_discordBotToken.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _Stream_discordBotToken, discordBotToken, "f");
    }
    get manage() {
        return {
            add: (users) => {
                if (!utils_1.is.array(users)) {
                    users = [users];
                }
                for (const u of users) {
                    this.cache.set(u.handle, {
                        handle: u.handle,
                        channels: utils_1.is.array(u.channels)
                            ? u.channels?.map((c) => {
                                if ("channelId" in c &&
                                    utils_1.is.string(c.channelId) &&
                                    !tslib_1.__classPrivateFieldGet(this, _Stream_discordBotToken, "f")) {
                                    throw new Error(`[${package_json_1.name}, v${package_json_1.version}]: ERROR: (${u.handle}) includes a 'channelId' but no 'discordBotToken' was provided in the constructor!`);
                                }
                                return {
                                    searchId: c.searchId ||
                                        `${utils_1.snowflakes.generate()}`,
                                    roles: c.roles || [],
                                    color: utils_1.is.string(c.color) &&
                                        c.color.startsWith("#")
                                        ? c.color
                                        : "#49acfe",
                                    showButtons: utils_1.is.boolean(c.showButtons)
                                        ? c.showButtons
                                        : true,
                                    url: "url" in c ? c.url : null,
                                    channelId: "channelId" in c ? c.channelId : null,
                                    options: {
                                        username: utils_1.is.string(c.options?.username)
                                            ? c.options?.username || null
                                            : null,
                                        avatar: utils_1.is.string(c.options?.avatar)
                                            ? c.options?.avatar || null
                                            : null,
                                        content: utils_1.is.string(c.options?.content)
                                            ? c.options?.content || ""
                                            : "",
                                        embeds: utils_1.is.array(c.options?.embeds)
                                            ? c.options?.embeds || []
                                            : [],
                                        components: utils_1.is.array(c.options?.components)
                                            ? c.options?.components || []
                                            : [],
                                    },
                                    toggles: {
                                        reposts: utils_1.is.boolean(c.toggles?.reposts)
                                            ? c.toggles?.reposts === false
                                                ? false
                                                : true
                                            : true,
                                    },
                                };
                            })
                            : [],
                    });
                }
            },
            remove: (users) => {
                if (utils_1.is.string(users)) {
                    users = [users];
                }
                for (const u of users) {
                    this.cache.delete(u);
                }
            },
            get: (user) => this.cache.get(user) || null,
            clear: () => this.cache.clear(),
            list: () => [...this.cache.values()],
            set: (user, searchId, options) => {
                if (!Object.keys(options).length) {
                    return utils_1.status.error(`You failed to provide any options to change.`);
                }
                const data = this.cache.get(user);
                if (!data) {
                    return utils_1.status.error(`User (${user}) wasn't found in the cache.`);
                }
                const channel = data.channels.find((c) => c.searchId === searchId);
                if (!channel) {
                    return utils_1.status.error(`User (${user}) doesn't have (${searchId}) searchId`);
                }
                const c = [];
                if (utils_1.is.string(options.channelId)) {
                    channel.channelId = options.channelId;
                    c.push(`channelId`);
                }
                if (utils_1.is.string(options.url)) {
                    channel.url = options.url;
                    c.push(`url`);
                }
                if (utils_1.is.string(options.color)) {
                    channel.color = options.color;
                    c.push(`color`);
                }
                if (utils_1.is.boolean(options.showButtons)) {
                    channel.showButtons = options.showButtons;
                    c.push(`showButtons`);
                }
                if (utils_1.is.array(options.roles, false)) {
                    channel.roles = options.roles;
                    c.push(`roles`);
                }
                if (utils_1.is.boolean(options.toggles?.reposts)) {
                    channel.toggles.reposts = options.toggles?.reposts ?? false;
                    c.push(`toggles.reposts`);
                }
                if (utils_1.is.object(options.options)) {
                    if (utils_1.is.string(options.options.content, false)) {
                        channel.options.content = options.options.content;
                        c.push(`options.content`);
                    }
                    if (utils_1.is.string(options.options.username, false)) {
                        channel.options.username = options.options.username;
                        c.push(`options.username`);
                    }
                    if (utils_1.is.string(options.options.avatar, false)) {
                        channel.options.avatar = options.options.avatar;
                        c.push(`options.avatar`);
                    }
                    if (utils_1.is.array(options.options.components, false)) {
                        channel.options.components = options.options.components;
                        c.push(`options.components`);
                    }
                    if (utils_1.is.array(options.options.embeds, false)) {
                        channel.options.embeds = options.options.embeds;
                        c.push(`options.embeds`);
                    }
                }
                if (!utils_1.is.array(c)) {
                    return utils_1.status.error(`Nothing needed to be updated.`);
                }
                return utils_1.status.data({
                    user: data,
                    channel,
                });
            },
        };
    }
    onPost(listener) {
        return this.stream.on("post", listener);
    }
    onDebug(listener) {
        return this.stream.on("debug", listener);
    }
    async start() {
        const users = this.manage.list();
        if (!utils_1.is.array(users)) {
            tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_debug).call(this, `[STREAM]: Ignoring, no users in the list, trying again in ${tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_mins_get)} minute(s)`);
            return tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_run).call(this);
        }
        // @ts-ignore
        await this.agent();
        for await (const c of (0, utils_2.chunk)(users, 25)) {
            tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_debug).call(this, `[STREAM:CHECK]: Checking (${c.length}) users for new posts.`);
            const feeds = await this.users.feeds.fetchMultiple(c.map((c) => c.handle), {
                checkAgainstTime: tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_mins_get),
                limit: 20,
            });
            if (feeds.status) {
                tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_debug).call(this, `[STREAM:CHECK]: Found (${feeds.data.size}) users with new posts.`);
                for (const [name, data] of feeds.data) {
                    const user = this.cache.get(name);
                    if (!user || !utils_1.is.array(data)) {
                        continue;
                    }
                    for (const post of data) {
                        this.stream.emit("post", user, post, (0, utils_2.formatPost)(post));
                        if (utils_1.is.array(user.channels)) {
                            // @ts-ignore
                            tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_handlePost).call(this, user, (0, utils_2.formatPost)(post), post.post);
                        }
                    }
                }
            }
            else {
                tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_debug).call(this, `[STREAM:CHECK]: No new posts by any users.`);
            }
        }
        return tslib_1.__classPrivateFieldGet(this, _Stream_instances, "m", _Stream_run).call(this);
    }
}
exports.Stream = Stream;
_Stream_discordBotToken = new WeakMap(), _Stream_instances = new WeakSet(), _Stream_name_get = function _Stream_name_get() {
    return `BlueSky`;
}, _Stream_icon_get = function _Stream_icon_get() {
    return `https://cdn.discordapp.com/emojis/1187876658355638372.png`;
}, _Stream_mins_get = function _Stream_mins_get() {
    return (this.options.searchMinutes || 1) * 60000;
}, _Stream_handlePost = async function _Stream_handlePost(user, post, viewed) {
    const send = async (webhook) => {
        if (!webhook.toggles.reposts &&
            post.reposted &&
            post.type === "repost") {
            return;
        }
        const opts = {
            content: "",
            embeds: [],
            components: [],
            username: webhook.options.username ||
                post.author.username ||
                tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_name_get),
            avatar_url: webhook.options.avatar || post.author.avatar || tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_icon_get),
        };
        let noContent = false;
        if (utils_1.is.array(webhook.roles)) {
            opts.content = webhook.roles.map((c) => `<@&${c}>`).join(" ");
        }
        post.text = (0, utils_2.transformText)(viewed);
        if (utils_1.is.string(webhook.options.content) ||
            utils_1.is.array(webhook.options.embeds) ||
            utils_1.is.array(webhook.options.components)) {
            let isThereContent = false;
            const options = (0, parser_1.parse)(webhook.options, post);
            if (utils_1.is.string(options.content)) {
                if (utils_1.is.string(opts.content)) {
                    opts.content =
                        `${opts.content}, ${options.content}`.slice(0, 2000);
                }
                else {
                    opts.content = options.content;
                }
                isThereContent = true;
            }
            if (utils_1.is.array(options.embeds)) {
                isThereContent = true;
                opts.embeds = options.embeds;
            }
            if (utils_1.is.array(options.components)) {
                isThereContent = true;
                opts.components = options.components;
            }
            noContent = isThereContent;
        }
        if (!noContent) {
            const embed = {
                author: { name: tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_name_get), icon_url: tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_icon_get) },
                title: `${post.author.username} (\`${post.author.handle}\`)`,
                url: post.links.url,
                description: utils_1.is.string(post.text)
                    ? post.text.slice(0, 4000)
                    : "",
                color: (0, utils_1.resolveColor)(webhook.color),
                image: post.images.length
                    ? { url: post.images[0] }
                    : undefined,
                timestamp: post.createdAt,
                thumbnail: { url: post.author.avatar || tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_icon_get) },
            };
            if (post.type === "repost" && post.reposted) {
                opts.username = post.reposted.user.username;
                opts.avatar_url = post.reposted.user.avatar;
                embed.color = 0x62f84a;
                embed.timestamp = post.reposted.createdAt;
            }
            opts.embeds.push(embed);
            if (post.images.length > 1) {
                for (const img of post.images.slice(1)) {
                    opts.embeds.push({
                        url: post.links.url,
                        image: { url: img },
                    });
                }
            }
            if (webhook.showButtons) {
                opts.components.push({
                    type: 1,
                    components: [
                        {
                            type: 2,
                            style: 5,
                            url: post.links.url,
                            label: `View${post.reposted ? ` Repost` : ""}`,
                        },
                    ],
                });
            }
        }
        if (utils_1.is.string(webhook.url)) {
            const hook = new webhooks_1.DiscordWebhook(webhook.url, {
                username: opts.username,
                avatar_url: opts.avatar_url,
            });
            if (utils_1.is.string(opts.content)) {
                hook.content(opts.content);
            }
            if (utils_1.is.array(opts.embeds)) {
                hook.embeds(opts.embeds);
            }
            if (utils_1.is.array(opts.components)) {
                // @ts-ignore
                hook.buttons(opts.components);
            }
            await hook.send().catch(console.error);
        }
        if (utils_1.is.string(webhook.channelId) &&
            utils_1.is.string(tslib_1.__classPrivateFieldGet(this, _Stream_discordBotToken, "f"))) {
            await new webhooks_1.Webhook(tslib_1.__classPrivateFieldGet(this, _Stream_discordBotToken, "f"))
                .send(webhook.channelId, {
                // @ts-ignore
                components: opts.components,
                content: opts.content,
                // @ts-ignore
                embeds: opts.embeds,
                webhook: {
                    name: opts.username,
                    icon: opts.avatar_url,
                },
            }, false, false)
                .catch(console.error);
        }
        return;
    };
    for await (const webhook of user.channels) {
        await send(webhook);
    }
    return;
}, _Stream_run = function _Stream_run() {
    return setTimeout(() => this.start(), tslib_1.__classPrivateFieldGet(this, _Stream_instances, "a", _Stream_mins_get));
}, _Stream_debug = function _Stream_debug(...args) {
    this.stream.emit("debug", ...args);
    // @ts-ignore
    this.debug(...args);
};
