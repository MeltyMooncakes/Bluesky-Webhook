"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertiOSShit = exports.getAverage = exports.getNearest = exports.resolveColor = exports.DefaultColors = exports.decodeHTML = exports.generate = exports.getKeys = exports.getEntries = exports.env = exports.colors = exports.formatNumber = exports.shuffle = exports.createBin = exports.hasBit = exports.proper = exports.chunk = exports.sleep = exports.bins = exports.binDefs = exports.services = void 0;
const sdk_1 = require("@elara-services/sdk");
const is_1 = require("./is");
exports.services = new sdk_1.SDK();
// eslint-disable-next-line prefer-const
exports.binDefs = {
    viewer: `https://view.elara.workers.dev`,
};
// eslint-disable-next-line prefer-const
exports.bins = {
    mine: "https://h.elara.workers.dev",
    haste: "https://h.s8n.workers.dev",
    pizza: "https://haste.unbelievaboat.com",
};
function sleep(timeout) {
    return new Promise((r) => setTimeout(r, timeout));
}
exports.sleep = sleep;
function chunk(arr, size) {
    const array = [];
    for (let i = 0; i < arr.length; i += size) {
        array.push(arr.slice(i, i + size));
    }
    return array;
}
exports.chunk = chunk;
function proper(name, splitBy) {
    if (name.startsWith("us-")) {
        const split = name.split("-")[1];
        return `US ${split.slice(0, 1).toUpperCase() + `${split.slice(1, split.length).toLowerCase()}`}`;
    }
    const str = `${name.slice(0, 1).toUpperCase()}${name.slice(1, name.length).toLowerCase()}`, by = (n) => str
        .split(n)
        .map((c) => `${c.slice(0, 1).toUpperCase()}${c.slice(1, c.length).toLowerCase()}`)
        .join(" ");
    if (str.includes("_")) {
        return by("_");
    }
    if (str.includes(".")) {
        return by(".");
    }
    if (splitBy && str.includes(splitBy)) {
        return by(splitBy);
    }
    return str;
}
exports.proper = proper;
function hasBit(bitfield, bit) {
    if ((bitfield & bit) === bit) {
        return true;
    }
    return false;
}
exports.hasBit = hasBit;
async function createBin(title, args, ext = "js", bin = "mine-f", priv = false) {
    const fetch = async (args, url, backup) => {
        if (!exports.services) {
            return null;
        }
        let res = await exports.services.haste.post(args, {
            extension: ext ?? "js",
            url,
        });
        if (!res.status) {
            res = await exports.services.haste.post(args, {
                extension: ext ?? "js",
                url: backup,
            });
        }
        return res.status ? res.url : `Unable to create any paste link.`;
    };
    if (bin === "mine-f") {
        const b = await exports.services.paste.post(title, args, priv);
        if (!b.status) {
            return fetch(args, exports.bins.mine, exports.bins.haste);
        }
        if (["messages", "discord"].includes(ext)) {
            return `${exports.binDefs.viewer}/${ext}/${b.id}`;
        }
        return `${exports.binDefs.viewer}/bin/${b.id}`;
    }
    const binUrl = exports.bins[bin];
    if (is_1.is.string(binUrl)) {
        return fetch(args, binUrl, bin === "mine" ? exports.bins.haste : exports.bins.mine);
    }
    return fetch(args, bin.match(/http(s)?:\/\//i) ? bin : exports.bins.mine, exports.bins.mine);
}
exports.createBin = createBin;
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
exports.shuffle = shuffle;
function formatNumber(num, showInfinitySymbol = false) {
    if (showInfinitySymbol && num === Infinity) {
        return "∞";
    }
    return num.toLocaleString();
}
exports.formatNumber = formatNumber;
exports.colors = {
    red: 0xff0000,
    green: 0xff000,
    yellow: 0xfaff00,
    orange: 0xff8300,
    cyan: 0x00ffe9,
    purple: 0xb28dff,
    default: 0x36393e,
};
exports.env = {
    get: (name, parseObj = false) => {
        if (!process.env[name]) {
            return "";
        }
        const str = Buffer.from(process.env[name], "base64").toString();
        if (parseObj) {
            try {
                return JSON.parse(str);
            }
            catch {
                return {};
            }
        }
        return str;
    },
    getObj: (name) => exports.env.get(name, true),
    parse: (data) => Buffer.from(data).toString("base64"),
};
const getEntries = (obj) => Object.entries(obj);
exports.getEntries = getEntries;
const getKeys = (obj) => Object.keys(obj);
exports.getKeys = getKeys;
function generate(length = 10, options) {
    let upperLetters = options?.upperLetters ?? true;
    let lowerLetters = options?.lowerLetters ?? true;
    let numbers = options?.numbers ?? true;
    let symbols = options?.symbols ?? false;
    if (!length || length <= 0) {
        length = 10;
    }
    if (!upperLetters && !lowerLetters && !numbers && !symbols) {
        upperLetters = true;
        lowerLetters = true;
        numbers = false;
        symbols = false;
    }
    let charatters = "";
    if (upperLetters) {
        charatters += "ABCDEFGHIJKLMNOPQRSTUWXYZ";
    }
    if (lowerLetters) {
        charatters += "abcdefghijklmnpqrstuwxyz";
    }
    if (numbers) {
        charatters += "1234567890";
    }
    if (symbols) {
        charatters += "!@#$%^&*.()";
    }
    let code = "";
    for (let i = 0; i < length; i++) {
        code += charatters.charAt(Math.floor(Math.random() * charatters.length));
    }
    return code;
}
exports.generate = generate;
function decodeHTML(str) {
    return String(str)
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/(&#(\d+);)/g, (m, c, charCode) => String.fromCharCode(charCode));
}
exports.decodeHTML = decodeHTML;
exports.DefaultColors = {
    DEFAULT: 0x000000,
    WHITE: 0xffffff,
    AQUA: 0x1abc9c,
    GREEN: 0x2ecc71,
    BLUE: 0x3498db,
    YELLOW: 0xffff00,
    PURPLE: 0x9b59b6,
    LUMINOUS_VIVID_PINK: 0xe91e63,
    GOLD: 0xf1c40f,
    ORANGE: 0xe67e22,
    RED: 0xe74c3c,
    GREY: 0x95a5a6,
    NAVY: 0x34495e,
    DARK_AQUA: 0x11806a,
    DARK_GREEN: 0x1f8b4c,
    DARK_BLUE: 0x206694,
    DARK_PURPLE: 0x71368a,
    DARK_VIVID_PINK: 0xad1457,
    DARK_GOLD: 0xc27c0e,
    DARK_ORANGE: 0xa84300,
    DARK_RED: 0x992d22,
    DARK_GREY: 0x979c9f,
    DARKER_GREY: 0x7f8c8d,
    LIGHT_GREY: 0xbcc0c0,
    DARK_NAVY: 0x2c3e50,
    BLURPLE: 0x7289da,
    GREYPLE: 0x99aab5,
    DARK_BUT_NOT_BLACK: 0x2c2f33,
    NOT_QUITE_BLACK: 0x23272a,
};
function resolveColor(color) {
    if (typeof color === "string") {
        if (color === "RANDOM") {
            return Math.floor(Math.random() * (0xffffff + 1));
        }
        if (color === "DEFAULT") {
            return exports.DefaultColors.DEFAULT;
        }
        color = exports.DefaultColors[color] || parseInt(color.replace("#", ""), 16);
    }
    else if (Array.isArray(color)) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
    }
    if (typeof color === "number") {
        if (color < 0 || color > 0xffffff) {
            color = 0;
        }
        else if (color && isNaN(color)) {
            color = 0;
        }
    }
    return color;
}
exports.resolveColor = resolveColor;
function getNearest(n, maxNumber = 1000) {
    if (n < 0) {
        return 0;
    }
    return Math.ceil(n / maxNumber) * maxNumber;
}
exports.getNearest = getNearest;
function getAverage(arr) {
    return Math.floor(arr.reduce((a, b) => a + b) / arr.length);
}
exports.getAverage = getAverage;
function convertiOSShit(str) {
    // Fuck you Apple
    return str.replace(/’/g, "'").replace(/“|”/g, '"');
}
exports.convertiOSShit = convertiOSShit;
