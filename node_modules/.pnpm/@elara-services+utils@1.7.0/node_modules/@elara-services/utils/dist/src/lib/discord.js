"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listenForRawEvents = exports.displayButtonRandomly = exports.addButtonRow = exports.addButton = exports.awaitMessages = exports.awaitMessage = exports.awaitComponent = exports.getConfirmPrompt = exports.embedComment = exports.dis = exports.Invites = exports.react = exports.deleteMessage = exports.lazyField = exports.setMobileStatusIcon = exports.discord = exports.fetchAllGuildBans = exports.fetchMessages = exports.canTakeActionAgainstMember = exports.createREST = exports.isV13 = void 0;
const collection_1 = require("@discordjs/collection");
const rest_1 = require("@discordjs/rest");
const snowflake_1 = require("@sapphire/snowflake");
const v10_1 = require("discord-api-types/v10");
const discord_js_1 = require("discord.js");
const extra_1 = require("./extra");
const is_1 = require("./is");
const permissions_1 = require("./permissions");
const responders_1 = require("./responders");
const status_1 = require("./status");
const times_1 = require("./times");
const utils_1 = require("./utils");
function isV13() {
    return discord_js_1.version.startsWith("13.");
}
exports.isV13 = isV13;
function createREST(client) {
    if (client instanceof discord_js_1.Client) {
        if (client.rest instanceof rest_1.REST) {
            return client.rest;
        }
        client = client.token;
    }
    return is_1.is.string(client) ? new rest_1.REST().setToken(client) : client;
}
exports.createREST = createREST;
function canTakeActionAgainstMember(mod, member, permissions) {
    if (!(member instanceof discord_js_1.GuildMember) || !(mod instanceof discord_js_1.GuildMember) || !is_1.is.array(permissions) || !member.guild.members.me || [member.guild.ownerId, member.client.user.id].includes(member.id)) {
        return false;
    }
    if (member.guild.members.me.roles.highest.comparePositionTo(member.roles.highest) < 0) {
        return false;
    }
    if (mod.roles.highest.comparePositionTo(member.roles.highest) < 0) {
        return false;
    }
    if (permissions.some((c) => member.permissions.has(c))) {
        return false;
    }
    return true;
}
exports.canTakeActionAgainstMember = canTakeActionAgainstMember;
async function fetchMessages(botTokenOrREST, channelId, limit = 50, before, after) {
    const rest = createREST(botTokenOrREST);
    const getMessages = async (limit = 100, _before, _after) => {
        return (await rest
            .get(v10_1.Routes.channelMessages(channelId), {
            query: (0, rest_1.makeURLSearchParams)({ limit, before: _before || undefined, after: _after || undefined }),
        })
            .catch(() => []));
    };
    if (limit && limit > 100) {
        let logs = [];
        const get = async (_before, _after) => {
            const messages = await getMessages(100, _before || undefined, _after || undefined);
            if (limit <= messages.length) {
                return _after
                    ? messages
                        .slice(messages.length - limit, messages.length)
                        .map((message) => message)
                        .concat(logs)
                    : logs.concat(messages.slice(0, limit).map((message) => message));
            }
            limit -= messages.length;
            logs = _after ? messages.map((message) => message).concat(logs) : logs.concat(messages.map((message) => message));
            if (messages.length < 100) {
                return logs;
            }
            return get((_before || !_after) && messages[messages.length - 1].id, _after && messages[0].id);
        };
        return get(before, after);
    }
    return await getMessages(limit, before, after);
}
exports.fetchMessages = fetchMessages;
async function fetchAllGuildBans(guild, options) {
    const bans = [
        ...(await guild.bans
            .fetch({
            after: options.after,
            before: options.before,
            limit: options.limit && Math.min(options.limit, 1000),
        })
            .catch(() => new collection_1.Collection())).values(),
    ];
    if (options.limit && options.limit > 1000 && bans.length >= 1000) {
        const page = await fetchAllGuildBans(guild, {
            after: options.before ? undefined : bans[bans.length - 1].user.id,
            before: options.before ? bans[0].user.id : undefined,
            limit: options.limit - bans.length,
        });
        bans[options.before ? "unshift" : "push"](...page);
    }
    return bans;
}
exports.fetchAllGuildBans = fetchAllGuildBans;
exports.discord = {
    user: async (client, args, { force, fetch, mock } = {
        fetch: true,
        force: false,
        mock: false,
    }) => {
        if (!client || !client.isReady() || !args) {
            return null;
        }
        if (!is_1.is.boolean(force)) {
            force = false;
        }
        if (!is_1.is.boolean(fetch)) {
            fetch = true;
        }
        if (!is_1.is.boolean(mock)) {
            mock = false;
        }
        const matches = args.match(/^(?:<@!?)?([0-9]+)>?$/);
        if (!matches) {
            return client.users.cache.find((c) => c.tag.toLowerCase().includes(args.toLowerCase())) ?? null;
        }
        const getMock = () => {
            if (mock) {
                // @ts-ignore
                return new discord_js_1.User(client, {
                    username: "Unknown User",
                    discriminator: "0000",
                    id: matches[1],
                });
            }
            return null;
        };
        if (client.users.cache.has(matches[1])) {
            if (force) {
                return client.users.fetch(matches[1], { cache: true, force: true }).catch(() => getMock());
            }
            return client.users.resolve(matches[1]);
        }
        if (!fetch && !mock && !force) {
            return null;
        }
        if (fetch) {
            return client.users.fetch(matches[1], { cache: true, force: true }).catch(() => getMock());
        }
        return getMock();
    },
    role: async (guild, id) => {
        if (!guild?.roles || !is_1.is.string(id)) {
            return null;
        }
        const matches = id.match(/^(?:<@&?)?([0-9]+)>?$/);
        if (!matches) {
            return guild.roles.cache.find((c) => c.name.toLowerCase() === id.toLowerCase() || c.name.toLowerCase().includes(id.toLowerCase())) || null;
        }
        return guild.roles.fetch(matches[1], { cache: true }).catch(() => null);
    },
    channel: async (client, id, guildToSearch = null, options) => {
        if (!client || !is_1.is.string(id)) {
            return null;
        }
        const hm = id.match(/^(?:<#?)?([0-9]+)>?$/);
        if (!hm) {
            if (guildToSearch) {
                const find = guildToSearch?.channels?.cache?.find?.((c) => c.name.includes(id));
                if (find) {
                    return find;
                }
            }
            return null;
        }
        if (client.channels.cache.has(hm[1])) {
            return client.channels.resolve(hm[1]);
        }
        const c = await client.channels.fetch(hm[1], options).catch(() => null);
        if (!c) {
            return null;
        }
        return c;
    },
    member: async (guild, args, fetch = false, withPresences = true) => {
        if (!guild || !is_1.is.string(args)) {
            return null;
        }
        const matches = args.match(/^(?:<@!?)?([0-9]+)>?$/);
        if (!matches) {
            return guild.members.cache.find((c) => c.user.tag.toLowerCase().includes(args.toLowerCase())) ?? null;
        }
        let m = guild.members.resolve(matches[1]);
        if (!m) {
            if (fetch) {
                m = await guild.members
                    .fetch({
                    user: matches[1],
                    withPresences,
                })
                    .catch(() => null);
                if (m instanceof collection_1.Collection) {
                    return m.first() ?? null;
                }
                else if (m) {
                    return m ?? null;
                }
            }
            if (!m) {
                return null;
            }
        }
        return m;
    },
    messages: {
        send: async ({ client, channelId, options, }, errorHandler = () => { }) => {
            const isFunc = typeof errorHandler === "function";
            const channel = await exports.discord.channel(client, channelId);
            if (!channel || !("send" in channel)) {
                if (isFunc) {
                    errorHandler(new Error(`[WARN] Failed to send message to channel: <#${channelId}> (${channelId})`));
                }
                return null;
            }
            return await channel.send(options).catch((e) => {
                if (isFunc) {
                    errorHandler(e);
                }
                return null;
            });
        },
        fetch: async ({ client, channelId, messageId, }, errorHandler = () => { }) => {
            const channel = await exports.discord.channel(client, channelId);
            if (!channel || !("messages" in channel)) {
                return null;
            }
            return await channel.messages.fetch(messageId).catch((e) => {
                errorHandler(e);
                return null;
            });
        },
        /**
         * @description Fetch messages in the channelId provided.
         * @note If the 'limit' is above 100, the bot will continue to fetch messages until the limit provided. (it will stop once there is no more messages to fetch in the channel)
         * @note Be careful with going above 100 limit, the bot will chunk the requests per-100 messages, meaning if you fetch 1000 messages, that's 10 requests the bot has to do)
         * @note The bot will follow the ratelimits Discord provides, so if you provide a large limit it will take longer for the function to return anything. (Example: 10k messages takes around ~2 minutes to complete)
         */
        fetchBulk: async (client, channelId, limit = 50) => {
            const messages = await fetchMessages(client.rest instanceof rest_1.REST ? client.rest : client.token, channelId, limit);
            if (!is_1.is.array(messages)) {
                return null;
            }
            // @ts-ignore
            return messages.map((c) => new discord_js_1.Message(client, c));
        },
        delete: async (clientOrToken, channelId, messageId) => {
            if (!channelId || !messageId) {
                throw new Error(`You didn't provide a channelId or a messageId`);
            }
            const rest = createREST(clientOrToken);
            return await rest.delete(v10_1.Routes.channelMessage(channelId, messageId));
        },
        /**
         * @description Bulk delete messages in a channel.
         * @note ignore.errors will ignore all errors while trying to bulkDelete, the 'errors' array sent will be empty.
         * @note ignore.old will remove message IDs before trying to bulkDelete, the returned 'old' field will provide the message IDs that is older than 2 weeks.
         */
        bulkDelete: async (clientOrToken, channelId, messages, ignore = { errors: true, old: true }) => {
            const old = messages.filter((c) => Date.now() - snowflake_1.DiscordSnowflake.timestampFrom(c) > 1209600000);
            if (ignore?.old === true) {
                messages = messages.filter((c) => !old.includes(c));
            }
            if (messages.length < 2) {
                throw new Error(`Min messages to delete is 2, you provided ${messages.length}`);
            }
            const rest = createREST(clientOrToken);
            const success = [];
            const errors = [];
            const del = async (c = []) => {
                const r = await rest
                    .post(v10_1.Routes.channelBulkDelete(channelId), {
                    body: { messages: c },
                })
                    .catch((e) => {
                    if (ignore?.errors === true) {
                        return null;
                    }
                    errors.push({ messages: c, error: new Error(e || "Unknown Error while trying to bulkDelete") });
                    return null;
                });
                if (r) {
                    success.push(...c);
                }
                return true;
            };
            if (messages.length > 100) {
                const chunked = (0, extra_1.chunk)(messages, 100);
                await Promise.all(chunked.map((c) => del(c)));
            }
            else {
                await del(messages);
            }
            return { success, errors, old };
        },
    },
};
function setMobileStatusIcon(deviceType = "iOS") {
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    require("@discordjs/ws").DefaultWebSocketManagerOptions.identifyProperties.browser = `Discord ${deviceType}`;
}
exports.setMobileStatusIcon = setMobileStatusIcon;
function lazyField(embed, name = "\u200b", value = "\u200b", inline = false) {
    if ("addFields" in embed) {
        return embed.addFields((0, utils_1.field)(name, value, inline));
    }
    return (0, utils_1.field)(name, value, inline);
}
exports.lazyField = lazyField;
async function deleteMessage(message, timeout = 5000) {
    if (timeout <= 0) {
        return message.delete().catch(() => null);
    }
    return (0, extra_1.sleep)(timeout).then(() => message.delete().catch(() => null));
}
exports.deleteMessage = deleteMessage;
async function react(message, emojis) {
    if (!(0, permissions_1.checkChannelPerms)(message.channel, message.client.user.id, 347200n)) {
        return null;
    }
    if (is_1.is.array(emojis)) {
        for (const e of emojis.reverse()) {
            message.react(e).catch(() => null);
        }
        return true;
    }
    if (is_1.is.string(emojis)) {
        return message
            .react(emojis)
            .then(() => true)
            .catch(() => false);
    }
    return false;
}
exports.react = react;
exports.Invites = {
    cache: new collection_1.Collection(),
    compare: (c, s) => {
        for (let i = 0; i < c.length; i++) {
            if (c[i] !== s[i]) {
                return c[i];
            }
        }
        return "";
    },
    used: async (guild) => {
        if (!guild?.members?.me?.permissions?.has?.(48n)) {
            return null;
        }
        const f = (i) => `${i.code}|${i.uses ? i.uses : "â™¾"}|${i.inviter?.id ?? "None"}`;
        const Cached = (invs) => {
            exports.Invites.cache.set(guild.id, invs.map(f));
            return null;
        };
        const invites = await guild.invites.fetch().catch(() => null);
        if (!invites) {
            return null;
        }
        const CachedInvites = exports.Invites.cache.get(guild.id);
        const currentInvites = invites.map(f);
        if (!CachedInvites?.length) {
            return Cached(invites);
        }
        if (CachedInvites.join(" ") === currentInvites.join(" ")) {
            if (guild.features.includes("VANITY_URL") && guild.vanityURLCode) {
                const owner = guild.members.resolve(guild.ownerId) || (await guild.members.fetch({ user: guild.ownerId }).catch(() => null)) || null;
                return {
                    code: guild.vanityURLCode,
                    uses: `â™¾`,
                    inviter: owner?.user ?? "[UNKNOWN_USER]",
                };
            }
            if (invites.size) {
                Cached(invites);
            }
            return null;
        }
        else {
            const used = exports.Invites.compare(currentInvites, CachedInvites);
            if (!is_1.is.string(used)) {
                return Cached(invites);
            }
            const [code, uses, inviter] = used.split("|");
            Cached(invites);
            return {
                code,
                uses: uses === "Infinite" ? "â™¾" : uses,
                inviter: await exports.discord.user(guild.client, inviter, { fetch: true, mock: true }),
            };
        }
    },
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    query: async (guild, options, guildInvites) => {
        return new Promise(async (r) => {
            if (!guild.features.includes("COMMUNITY")) {
                return r(status_1.status.error(`Server ${guild.name} (${guild.id}) doesn't have "COMMUNITY" enabled so this cannot be used.`));
            }
            let fetchInviters = true;
            let fetchUses = true;
            if (is_1.is.object(options.fetch)) {
                if (is_1.is.boolean(options.fetch.inviters)) {
                    fetchInviters = options.fetch.inviters;
                }
                if (is_1.is.boolean(options.fetch.uses)) {
                    fetchUses = options.fetch.uses;
                }
            }
            let data = new Error(`Unable to fetch the members invites.`);
            const fetch = async () => {
                if (isV13()) {
                    // @ts-ignore
                    data = (await guild.client.api
                        // @ts-ignore
                        .guilds(guild.id)("members-search")
                        .post({ data: options.search })
                        // @ts-ignore
                        .catch((e) => e));
                }
                else {
                    data = (await guild.client.rest.post(`/guilds/${guild.id}/members-search`, { body: options.search }).catch((e) => e));
                }
            };
            await fetch();
            if ("retry_after" in data) {
                await (0, extra_1.sleep)(data.retry_after * 1000);
                await fetch();
            }
            // @ts-ignore
            if (data instanceof Error || !is_1.is.array(data?.members || [])) {
                // @ts-ignore
                return r(status_1.status.error(data?.message || is_1.is.array(data?.members || [], false) ? "No users/invites returned by Discord" : "Unknown Issue while fetching it."));
            }
            // @ts-ignore
            data.members = data.members.map((c) => {
                const types = {
                    1: "bot",
                    2: "integration",
                    3: "server_discovery",
                    5: "normal",
                    6: "vanity",
                };
                // @ts-ignore
                c.joinType = types[c.join_source_type] || "unknown";
                return c;
            });
            if (is_1.is.array(options.fetch?.inviter_ids)) {
                // @ts-ignore
                data.members = data.members.filter((c) => {
                    if (!c.inviter_id || !options.fetch?.inviter_ids?.includes?.(c.inviter_id)) {
                        return false;
                    }
                    return true;
                });
            }
            if (fetchUses === true && guild.members.me?.permissions.has(48n)) {
                const invs = guildInvites ?? (await guild.invites.fetch({ cache: false }).catch(() => null));
                if (invs?.size) {
                    // @ts-ignore
                    data.members = data.members.map((c) => {
                        if ("source_invite_code" in c && c.source_invite_code) {
                            const d = invs.find((i) => i.code === c.source_invite_code);
                            c.uses = d?.uses || 0;
                            c.notFound = d ? false : true;
                        }
                        else {
                            c.uses = 0;
                            c.notFound = false;
                        }
                        return c;
                    });
                }
                else {
                    // @ts-ignore
                    data.members = data.members.map((c) => {
                        c.uses = 0;
                        c.notFound = true;
                        return c;
                    });
                }
            }
            else {
                // @ts-ignore
                data.members = data.members.map((c) => {
                    c.uses = 0;
                    c.notFound = false;
                    return c;
                });
            }
            if (fetchInviters === true) {
                // @ts-ignore
                data.members = await Promise.all(
                // @ts-ignore
                data.members.map(async (c) => {
                    if (c.join_source_type === 6) {
                        c.inviter = await exports.discord.user(guild.client, guild.ownerId, { fetch: true });
                    }
                    else if (c.inviter_id &&
                        [
                            1,
                            5, // Normal invite.
                        ].includes(c.join_source_type)) {
                        c.inviter = await exports.discord.user(guild.client, c.inviter_id, { fetch: true });
                    }
                    else {
                        c.inviter = null;
                    }
                    return c;
                }));
            }
            else {
                // @ts-ignore
                data.members = data.members.map((c) => {
                    c.inviter = null;
                    return c;
                });
            }
            return r(status_1.status.data(data));
        });
    },
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    fetch: async (guild, users, fetchInviters, fetchUses) => {
        return new Promise(async (r) => {
            return r(await exports.Invites.query(guild, {
                search: {
                    limit: users.length,
                    and_query: { user_id: { or_query: users } },
                },
                fetch: {
                    inviters: fetchInviters,
                    uses: fetchUses,
                },
            }));
        });
    },
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    by: async (guild, user, limit = 1000, onlyValidInvites = true) => {
        return new Promise(async (r) => {
            const list = is_1.is.array(user) ? user : [user];
            let invites = new collection_1.Collection();
            if (guild.members.me?.permissions.has(48n) && onlyValidInvites === true) {
                const invs = await guild.invites.fetch({ cache: false }).catch(() => null);
                if (invs && invs.size) {
                    invites = invs;
                }
            }
            const validInvites = onlyValidInvites && invites.size ? invites.filter((c) => c.inviterId && list.includes(c.inviterId) && is_1.is.number(c.uses) && c.uses >= 1).map((c) => c.code) : [];
            return r(await exports.Invites.query(guild, {
                search: {
                    limit,
                    and_query: {
                        join_source_type: {
                            or_query: [5],
                        },
                        ...(validInvites.length
                            ? {
                                source_invite_code: {
                                    or_query: validInvites,
                                },
                            }
                            : {}),
                    },
                },
                fetch: {
                    inviters: true,
                    uses: true,
                    inviter_ids: list,
                },
            }, invites));
        });
    },
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    formatBy: async (guild, user, limit = 1000, ignoreInactiveInvites = true) => {
        return new Promise(async (r) => {
            const list = is_1.is.array(user) ? user : [user];
            const data = await exports.Invites.by(guild, list, limit);
            if (!data.status) {
                return r(data);
            }
            const users = new collection_1.Collection();
            for (const id of list) {
                let l = data.data.members.filter((c) => c.inviter_id === id && c.source_invite_code);
                if (ignoreInactiveInvites === true) {
                    l = l.filter((c) => c.notFound === false && c.uses >= 1);
                }
                const li = [];
                for (const c of l) {
                    if (!c.source_invite_code) {
                        continue;
                    }
                    const f = li.find((cc) => cc.code === c.source_invite_code);
                    if (!f) {
                        li.push({
                            type: c.joinType,
                            code: c.source_invite_code,
                            uses: c.uses || 0,
                        });
                    }
                }
                users.set(id, {
                    invited: l.length || 0,
                    uses: li.map((c) => c.uses).reduce((a, b) => a + b, 0) || 0,
                    codes: li,
                    members: l || [],
                });
            }
            return r(status_1.status.data(users));
        });
    },
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    format: async (guild, users) => {
        const res = await exports.Invites.fetch(guild, users, true, true);
        if (!res.status || !is_1.is.array(res?.data?.members)) {
            return { status: false, message: `Unable to find any info regarding that user.` };
        }
        return {
            status: true,
            data: res.data.members,
        };
    },
};
exports.dis = {
    application: (app) => {
        return app instanceof discord_js_1.Application;
    },
    user: (user) => {
        return user instanceof discord_js_1.User;
    },
    member: (member) => {
        return member instanceof discord_js_1.GuildMember;
    },
    guild: (guild) => {
        return guild instanceof discord_js_1.Guild;
    },
    role: (role) => {
        return role instanceof discord_js_1.Role;
    },
    client: (client) => {
        return client instanceof discord_js_1.Client;
    },
    channels: {
        text: (channel) => {
            return channel instanceof discord_js_1.TextChannel;
        },
        voice: (channel) => {
            return channel instanceof discord_js_1.VoiceChannel;
        },
        thread: (channel) => {
            return channel instanceof discord_js_1.ThreadChannel;
        },
        forum: (channel) => {
            return channel instanceof discord_js_1.ForumChannel;
        },
        category: (channel) => {
            return channel instanceof discord_js_1.CategoryChannel;
        },
    },
};
function embedComment(str, color = "Red", components = [], files = []) {
    return {
        content: "",
        embeds: [new discord_js_1.EmbedBuilder().setDescription(str).setColor(typeof color === "number" ? color : discord_js_1.Colors[color])],
        components,
        files,
    };
}
exports.embedComment = embedComment;
async function getConfirmPrompt(channelOrInteraction, user, str, timer = status_1.get.secs(30)) {
    let msg;
    const options = {
        embeds: [
            {
                author: { name: user.displayName, icon_url: user.displayAvatarURL() },
                title: `Prompt`,
                description: str,
                color: extra_1.colors.orange,
                fields: [{ name: "\u200b", value: `> Expires ${times_1.time.countdown(timer)}` }],
                footer: {
                    text: `ID: ${user.id}`,
                },
            },
        ],
        components: [
            {
                type: 1,
                components: [
                    {
                        type: 2,
                        custom_id: `prompt:confirm`,
                        label: "Confirm",
                        style: 3,
                    },
                    {
                        type: 2,
                        custom_id: `prompt:cancel`,
                        label: "Cancel",
                        style: 4,
                    },
                ],
            },
        ],
    };
    if ("deferred" in channelOrInteraction) {
        if (channelOrInteraction.deferred) {
            msg = await channelOrInteraction.editReply(options).catch(() => null);
        }
        else {
            msg = await channelOrInteraction
                .reply({
                fetchReply: true,
                ...options,
            })
                .catch(() => null);
        }
    }
    else {
        msg = await channelOrInteraction.send(options).catch(() => null);
    }
    if (!msg) {
        return null;
    }
    const col = await msg
        .awaitMessageComponent({
        filter: (i) => i.user.id === user.id && i.customId.startsWith("prompt:") && i.isButton(),
        time: timer,
    })
        .catch(() => null);
    if (!col) {
        await msg
            .edit({
            embeds: [(0, responders_1.comment)(`Cancelled`, extra_1.colors.red, true)],
        })
            .catch(() => null);
        return null;
    }
    if (!col.customId.includes("confirm")) {
        await col
            .update({
            embeds: [(0, responders_1.comment)(`Cancelled`, extra_1.colors.red, true)],
        })
            .catch(() => null);
        return null;
    }
    await col.deferUpdate().catch(() => null);
    return col;
}
exports.getConfirmPrompt = getConfirmPrompt;
async function awaitComponent(messageOrChannel, options) {
    const filter = (i) => {
        if (!("customId" in i)) {
            return false;
        }
        if (is_1.is.array(options.users)) {
            for (const user of options.users.filter((c) => c.allow === true)) {
                if (user.id !== i.user.id) {
                    return false;
                }
            }
            const find = options.users.find((c) => c.id === i.user.id);
            if (find) {
                if (!find.allow) {
                    return false;
                }
            }
        }
        return options.custom_ids.some((c) => (c.includes ? i.customId.includes(c.id) : i.customId === c.id));
    };
    const col = await messageOrChannel
        .awaitMessageComponent({
        filter,
        time: options.time ?? status_1.get.secs(30),
    })
        .catch(() => null);
    if (!col) {
        return null;
    }
    return col;
}
exports.awaitComponent = awaitComponent;
async function awaitMessage(channel, options = {
    filter: (m) => !m.author.bot,
    time: status_1.get.secs(30),
}) {
    const f = await channel
        .awaitMessages({
        filter: options.filter,
        time: options.time || status_1.get.secs(30),
        max: 1,
        errors: ["time"],
    })
        .catch(() => null);
    if (!f?.size) {
        return null;
    }
    return f.first();
}
exports.awaitMessage = awaitMessage;
async function awaitMessages(channel, options = {
    filter: (m) => !m.author.bot,
    max: 1,
    time: status_1.get.secs(30),
}) {
    const f = await channel
        .awaitMessages({
        filter: options.filter,
        time: options.time || status_1.get.secs(30),
        max: options.max || 1,
        errors: ["time"],
    })
        .catch(() => null);
    if (!f?.size) {
        return null;
    }
    return [...f.values()];
}
exports.awaitMessages = awaitMessages;
function addButton(options) {
    const button = new discord_js_1.ButtonBuilder();
    if (options.id) {
        button.setCustomId(options.id);
    }
    if (options.url) {
        button.setURL(options.url).setStyle(discord_js_1.ButtonStyle.Link);
    }
    else if (options.style) {
        button.setStyle(options.style);
    }
    if (options.label) {
        button.setLabel(options.label);
    }
    if (options.emoji) {
        button.setEmoji(options.emoji);
    }
    if (is_1.is.boolean(options.disabled)) {
        button.setDisabled(options.disabled);
    }
    if (!button.data.label && !button.data.emoji) {
        button.setEmoji("ðŸ¤”"); // This only happens if there is no label or emoji to avoid erroring out the command.
    }
    return button;
}
exports.addButton = addButton;
function addButtonRow(options) {
    const row = new discord_js_1.ActionRowBuilder();
    if (Array.isArray(options) && options.length) {
        for (const option of options) {
            row.addComponents(addButton(option));
        }
    }
    else if (is_1.is.object(options)) {
        row.addComponents(addButton(options));
    }
    return row;
}
exports.addButtonRow = addButtonRow;
function displayButtonRandomly(button, options = {
    top: 3,
    middle: 3,
    bottom: 3,
}, defaultButtons) {
    const get = (num) => new Array(num).fill(0).map(() => ({
        id: utils_1.snowflakes.generate(),
        emoji: defaultButtons?.emoji || { id: "868584026913505281" },
        style: defaultButtons?.style || discord_js_1.ButtonStyle.Secondary,
        label: defaultButtons?.label || undefined,
    }));
    const t = get(options.top ?? 3);
    const m = get(options.middle ?? 3);
    const b = get(options.bottom ?? 3);
    const all = [...t, ...m, ...b];
    (0, extra_1.shuffle)(all);
    let random = all[Math.floor(Math.random() * all.length)];
    while (!random) {
        random = all[Math.floor(Math.random() * all.length)];
    }
    return (0, extra_1.chunk)(all.map((c) => {
        if (c.id === random.id) {
            c = button;
        }
        return c;
    }), 3).map((c) => addButtonRow(c));
}
exports.displayButtonRandomly = displayButtonRandomly;
function listenForRawEvents(client, events, once = false) {
    if (!is_1.is.array(events)) {
        return (0, times_1.log)(`[LISTEN:FOR:RAW:EVENTS]: No events provided.`);
    }
    if (!exports.dis.client(client)) {
        return (0, times_1.log)(`[LISTEN:FOR:RAW:EVENTS]: Invalid client provided.`);
    }
    client[once ? "once" : "on"]("raw", (p) => {
        if (!p.t || !p.d) {
            return;
        }
        const e = p.t.toLowerCase();
        for (const event of events) {
            if (is_1.is.string(event.name)) {
                if (event.includes === true) {
                    if (e.includes(event.name)) {
                        event.run(p.t, p.d);
                        continue;
                    }
                }
                else {
                    if (event.name === e) {
                        event.run(p.t, p.d);
                        continue;
                    }
                }
            }
            if (event.regex) {
                if (e.match(event.regex)) {
                    event.run(p.t, p.d);
                    continue;
                }
            }
        }
    });
}
exports.listenForRawEvents = listenForRawEvents;
