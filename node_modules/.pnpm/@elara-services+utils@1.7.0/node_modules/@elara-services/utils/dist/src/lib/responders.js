"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSubCommand = exports.handleSubCommands = exports.getMessageResponder = exports.getInteractionResponder = exports.comment = exports.embed = void 0;
const builders_1 = require("@discordjs/builders");
const discord_js_1 = require("discord.js");
const _1 = require(".");
const package_json_1 = __importDefault(require("../../package.json"));
/**
 * @description Provides a @discordjs/builders EmbedBuilder class to use, however... if you're on discord.js v13 make sure to use `.toJSON()` before sending it!
 */
function embed() {
    return new builders_1.EmbedBuilder();
}
exports.embed = embed;
function comment(description, color, toJSON = false) {
    const em = embed()
        .setDescription(description)
        .setColor((0, _1.resolveColor)(color) || _1.colors.red);
    return toJSON ? em.toJSON() : em;
}
exports.comment = comment;
function getInteractionResponder(interaction, handleErrors = _1.error) {
    return {
        reply: async (options) => {
            if (interaction.deferred) {
                if ("ephemeral" in options) {
                    delete options["ephemeral"];
                }
                return interaction.editReply(options).catch(handleErrors);
            }
            return interaction.reply(options).catch(handleErrors);
        },
        defer: async (options) => {
            if (interaction.deferred) {
                return;
            }
            return interaction.deferReply(options).catch(handleErrors);
        },
        edit: async (options) => {
            if (!interaction.deferred) {
                return;
            }
            return interaction.editReply(options).catch(handleErrors);
        },
        send: async (options) => {
            if (!interaction.channel || !interaction.channel.isTextBased()) {
                return;
            }
            return interaction.channel.send(options).catch(handleErrors);
        },
        update: async (options) => {
            if (!interaction.isButton() && !interaction.isAnySelectMenu()) {
                return;
            }
            return interaction.update(options).catch(() => void null);
        },
        deleteReply: async (timeout = 0) => {
            if (timeout > 0) {
                await (0, _1.sleep)(timeout);
            }
            return interaction.deleteReply().catch(() => void null);
        },
        deferUpdate: async (options) => {
            if (!interaction.isButton() && !interaction.isModalSubmit() && !interaction.isAnySelectMenu()) {
                return;
            }
            if (interaction.deferred) {
                // If it's already deferred, ignore.
                return;
            }
            return interaction.deferUpdate(options).catch(() => void null);
        },
        followUp: async (options) => {
            return interaction.followUp(options).catch(() => void null);
        },
        showModal: async (options) => {
            if (!interaction.isAnySelectMenu() && !interaction.isButton() && !interaction.isCommand()) {
                return;
            }
            return interaction.showModal(options).catch(() => void null);
        },
        raw: interaction,
    };
}
exports.getInteractionResponder = getInteractionResponder;
function getMessageResponder(message) {
    return {
        loading: async (str) => {
            return message
                .reply({
                embeds: [comment(str || `Loading, one moment...`, _1.colors.orange, true)],
                failIfNotExists: false,
            })
                .catch(_1.error);
        },
        delete: async (timeout = 0) => {
            if (timeout <= 0) {
                return message.delete().catch(_1.error);
            }
            await (0, _1.sleep)(timeout);
            return message.delete().catch(_1.error);
        },
        reply: async (options) => {
            return await message.reply(options).catch(_1.error);
        },
        send: async (options) => {
            if (!message.channel || !message.channel.isTextBased()) {
                return null;
            }
            const sentMessage = await message.channel.send(options).catch(_1.error);
            if (!sentMessage) {
                return null;
            }
            return getMessageResponder(sentMessage);
        },
        react: async (options) => {
            return message.react(options).catch(_1.error);
        },
        edit: async (options) => {
            return message.edit(options).catch(_1.error);
        },
        raw: message,
        args: message.content.split(/ +/g).slice(1),
    };
}
exports.getMessageResponder = getMessageResponder;
function handleSubCommands(interaction, files) {
    (0, _1.emitPackageMessage)(`handleSubCommands`, () => {
        console.warn(`${(0, _1.getPackageStart)(package_json_1.default)}: 'handleSubCommands' function is deprecated, use '@elara-services/botbuilder' version of it!`);
    });
    const responder = getInteractionResponder(interaction);
    const subCommandArg = interaction.options.getSubcommand();
    if (!(files instanceof discord_js_1.Collection)) {
        return;
    }
    const command = files.get(subCommandArg);
    if (!command) {
        return responder.reply({
            embeds: [comment(`I was unable to find that sub command`, "#FF0000", true)],
            ephemeral: true,
        });
    }
    return command.execute(interaction, responder);
}
exports.handleSubCommands = handleSubCommands;
function buildSubCommand(builder, commands) {
    (0, _1.emitPackageMessage)(`buildSubCommand`, () => {
        console.warn(`${(0, _1.getPackageStart)(package_json_1.default)}: 'buildSubCommand' function is deprecated, use '@elara-services/botbuilder' version of it!`);
    });
    const command = typeof builder === "function" ? builder(new discord_js_1.SlashCommandBuilder()) : builder;
    const subCommands = (0, _1.getFilesList)(commands);
    if (subCommands.size) {
        for (const subCommand of subCommands.values()) {
            if (!subCommand) {
                throw new Error("Unable to create slash command");
            }
            command.addSubcommand(subCommand.subCommand);
        }
    }
    return command;
}
exports.buildSubCommand = buildSubCommand;
