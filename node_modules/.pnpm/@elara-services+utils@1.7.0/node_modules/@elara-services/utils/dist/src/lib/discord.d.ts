/// <reference types="node" />
import { Collection } from "@discordjs/collection";
import { REST } from "@discordjs/rest";
import { type APIMessage } from "discord-api-types/v10";
import { ActionRowBuilder, Application, ButtonBuilder, ButtonStyle, CategoryChannel, Channel, Client, Colors, EmbedBuilder, ForumChannel, Guild, GuildMember, InteractionEditReplyOptions, Invite, Message, MessageActionRowComponentBuilder, MessageCreateOptions, MessagePayload, RepliableInteraction, Role, TextBasedChannel, TextChannel, ThreadChannel, User, VoiceChannel, type ButtonInteraction, type ChannelSelectMenuInteraction, type ComponentEmojiResolvable, type FetchChannelOptions, type GuildBan, type MentionableSelectMenuInteraction, type PermissionResolvable, type RoleSelectMenuInteraction, type StringSelectMenuInteraction, type UserSelectMenuInteraction } from "discord.js";
import { XOR } from "./jobs";
export type errorHandler = (e: Error) => unknown;
export declare function isV13(): boolean;
export declare function createREST(client: string | REST | Client): REST;
export declare function canTakeActionAgainstMember(mod: GuildMember, member: GuildMember, permissions: PermissionResolvable[]): boolean;
export declare function fetchMessages(botTokenOrREST: string | REST, channelId: string, limit?: number, before?: string, after?: string): Promise<APIMessage[]>;
export declare function fetchAllGuildBans(guild: Guild, options: {
    after?: string;
    before?: string;
    limit?: number;
}): Promise<GuildBan[]>;
export declare const discord: {
    user: (client: Client, args: string, { force, fetch, mock }?: DiscordUserOptions) => Promise<User | null>;
    role: (guild: Guild, id: string) => Promise<Role | null>;
    channel: <D extends Channel>(client: Client, id: string, guildToSearch?: Guild | null, options?: FetchChannelOptions) => Promise<D | null>;
    member: (guild: Guild, args: string, fetch?: boolean, withPresences?: boolean) => Promise<GuildMember | null>;
    messages: {
        send: ({ client, channelId, options, }: {
            client: Client<true>;
            channelId: string;
            options: string | MessagePayload | MessageCreateOptions;
        }, errorHandler?: errorHandler) => Promise<Message<true> | Message<false> | null>;
        fetch: ({ client, channelId, messageId, }: {
            client: Client<true>;
            channelId: string;
            messageId: string;
        }, errorHandler?: errorHandler) => Promise<Message | null>;
        /**
         * @description Fetch messages in the channelId provided.
         * @note If the 'limit' is above 100, the bot will continue to fetch messages until the limit provided. (it will stop once there is no more messages to fetch in the channel)
         * @note Be careful with going above 100 limit, the bot will chunk the requests per-100 messages, meaning if you fetch 1000 messages, that's 10 requests the bot has to do)
         * @note The bot will follow the ratelimits Discord provides, so if you provide a large limit it will take longer for the function to return anything. (Example: 10k messages takes around ~2 minutes to complete)
         */
        fetchBulk: (client: Client, channelId: string, limit?: number) => Promise<Message[] | null>;
        delete: (clientOrToken: Client | string, channelId: string, messageId: string) => Promise<unknown>;
        /**
         * @description Bulk delete messages in a channel.
         * @note ignore.errors will ignore all errors while trying to bulkDelete, the 'errors' array sent will be empty.
         * @note ignore.old will remove message IDs before trying to bulkDelete, the returned 'old' field will provide the message IDs that is older than 2 weeks.
         */
        bulkDelete: (clientOrToken: Client | string, channelId: string, messages: string[], ignore?: {
            errors?: boolean;
            old?: boolean;
        }) => Promise<{
            success: string[];
            errors: {
                messages: string[];
                error: Error;
            }[];
            old: string[];
        }>;
    };
};
export interface DiscordUserOptions {
    mock?: boolean;
    fetch?: boolean;
    force?: boolean;
}
export declare function setMobileStatusIcon(deviceType?: "iOS" | "Android"): void;
export declare function lazyField(embed: EmbedBuilder, name?: string, value?: string, inline?: boolean): {
    name: string;
    value: string;
    inline: boolean;
} | EmbedBuilder;
export declare function deleteMessage(message: Message, timeout?: number): Promise<Message<boolean> | null>;
export declare function react(message: Message, emojis: string[] | string): Promise<boolean | null>;
export type InviteResponseData<D> = {
    status: false;
    message: string;
} | {
    status: true;
    data: D;
};
export interface MakeInviteClientOptions {
    search: object;
    fetch?: {
        inviters?: boolean;
        uses?: boolean;
        inviter_ids?: string[];
    };
}
export interface FormatInvitedBy {
    invited: number;
    uses: number;
    codes: {
        type: Exclude<FetchedMemberInvite["joinType"], "bot" | "integration">;
        code: string;
        uses: number;
    }[];
    members: FetchedMemberInvite[];
}
export declare const Invites: {
    cache: Collection<string, string[]>;
    compare: (c: string[], s: string[]) => string;
    used: (guild: Guild) => Promise<{
        code: string;
        uses: string;
        inviter: string | User;
    } | {
        code: string;
        uses: string;
        inviter: User | null;
    } | null>;
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    query: (guild: Guild, options: MakeInviteClientOptions, guildInvites?: Collection<string, Invite>) => Promise<InviteResponseData<FetchedMemberInvitesResponse>>;
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    fetch: (guild: Guild, users: string[], fetchInviters?: boolean, fetchUses?: boolean) => Promise<InviteResponseData<FetchedMemberInvitesResponse>>;
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    by: (guild: Guild, user: string | string[], limit?: number, onlyValidInvites?: boolean) => Promise<InviteResponseData<FetchedMemberInvitesResponse>>;
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    formatBy: (guild: Guild, user: string | string[], limit?: number, ignoreInactiveInvites?: boolean) => Promise<InviteResponseData<Collection<string, FormatInvitedBy>>>;
    /**
     * [WARNING]:
     * - This uses an endpoint not documented and can be restricted to bots at any time by Discord.
     * - Due to caching on Discord's end an entry for a user might not show up for a few minutes to an hour+ (THIS CAN'T BE CHANGED)
     */
    format: (guild: Guild, users: string[]) => Promise<InviteResponseData<FetchedMemberInvitesResponse["members"]>>;
};
export interface FetchedMemberInvitesResponse {
    guild_id: string;
    members: FetchedMemberInvite[];
    page_result_count: number;
    total_result_count: number;
}
export interface FetchedMemberInvite {
    member: {
        avatar: string | null;
        communication_disabled_until: string | null;
        unusual_dm_activity_until: string | null;
        flags: number;
        joined_at: string | null;
        nick: string | null;
        pending: boolean;
        premium_since: string | null;
        roles: string[];
        user: {
            id: string;
            username: string;
            avatar: string | null;
            discriminator: string | "0000" | "0";
            public_flags: number;
            premium_type?: number;
            flags: number;
            banner: string | null;
            accent_color: string | null;
            global_name: string | null;
            avatar_decoration_data: object | null;
            banner_color: string | null;
        };
        mute: boolean;
        deaf: boolean;
    };
    source_invite_code: string | null;
    notFound: boolean;
    join_source_type: number;
    uses: number;
    inviter_id: string | null;
    joinType?: "bot" | "server_discovery" | "normal" | "vanity" | "integration" | "unknown";
    inviter?: User | null;
}
export declare const dis: {
    application: (app: any) => app is Application;
    user: (user: any) => user is User;
    member: (member: any) => member is GuildMember;
    guild: (guild: any) => guild is Guild;
    role: (role: any) => role is Role;
    client: (client: any) => client is Client<boolean>;
    channels: {
        text: (channel: any) => channel is TextChannel;
        voice: (channel: any) => channel is VoiceChannel;
        thread: (channel: any) => channel is ThreadChannel<boolean>;
        forum: (channel: any) => channel is ForumChannel;
        category: (channel: any) => channel is CategoryChannel;
    };
};
export declare function embedComment(str: string, color?: keyof typeof Colors | number, components?: ActionRowBuilder<MessageActionRowComponentBuilder>[], files?: InteractionEditReplyOptions["files"]): {
    content: string;
    embeds: EmbedBuilder[];
    components: ActionRowBuilder<MessageActionRowComponentBuilder>[];
    files: (import("discord.js").BufferResolvable | import("stream").Stream | import("@discordjs/util").JSONEncodable<import("discord.js").APIAttachment> | import("discord.js").Attachment | import("discord.js").AttachmentBuilder | import("discord.js").AttachmentPayload)[];
};
export declare function getConfirmPrompt(channelOrInteraction: TextBasedChannel | RepliableInteraction, user: User, str: string, timer?: number): Promise<StringSelectMenuInteraction<import("discord.js").CacheType> | UserSelectMenuInteraction<import("discord.js").CacheType> | RoleSelectMenuInteraction<import("discord.js").CacheType> | MentionableSelectMenuInteraction<import("discord.js").CacheType> | ChannelSelectMenuInteraction<import("discord.js").CacheType> | ButtonInteraction<import("discord.js").CacheType> | null>;
export type AnyInteraction = StringSelectMenuInteraction | UserSelectMenuInteraction | RoleSelectMenuInteraction | MentionableSelectMenuInteraction | ChannelSelectMenuInteraction | ButtonInteraction;
export declare function awaitComponent<D extends AnyInteraction>(messageOrChannel: Message | TextBasedChannel, options: {
    custom_ids: {
        id: string;
        includes?: boolean;
    }[];
    users?: {
        allow: boolean;
        id: string;
    }[];
    time?: number;
}): Promise<D | null>;
export type AwaitMessagesOptions = {
    max?: number;
    time?: number;
    filter?: (m: Message) => boolean;
};
export declare function awaitMessage(channel: TextBasedChannel, options?: Omit<AwaitMessagesOptions, "max">): Promise<Message<boolean> | null>;
export declare function awaitMessages(channel: TextBasedChannel, options?: AwaitMessagesOptions): Promise<Message<boolean>[] | null>;
export interface ButtonOptions {
    label?: string;
    style?: ButtonStyle;
    emoji?: ComponentEmojiResolvable;
    id?: string;
    url?: string;
    disabled?: boolean;
}
export declare function addButton(options: ButtonOptions): ButtonBuilder;
export declare function addButtonRow(options: ButtonOptions | ButtonOptions[]): ActionRowBuilder<ButtonBuilder>;
export type ValidNumber = 1 | 2 | 3 | 4 | 5;
export declare function displayButtonRandomly(button: ButtonOptions, options?: Partial<{
    top: ValidNumber;
    middle: ValidNumber;
    bottom: ValidNumber;
}>, defaultButtons?: Partial<{
    style: ButtonStyle;
    emoji: ComponentEmojiResolvable;
    label: string;
}>): ActionRowBuilder<ButtonBuilder>[];
export type EventOptions = XOR<{
    name: string;
    includes?: boolean;
    run: (eventName: string, ...args: unknown[]) => Promise<unknown> | unknown;
}, {
    regex: RegExp;
    run: (eventName: string, ...args: unknown[]) => Promise<unknown> | unknown;
}>;
export declare function listenForRawEvents(client: Client, events: EventOptions[], once?: boolean): void;
