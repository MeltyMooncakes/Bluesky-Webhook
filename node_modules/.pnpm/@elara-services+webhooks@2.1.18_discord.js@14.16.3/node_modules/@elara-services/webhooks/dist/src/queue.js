"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startQueue = exports.sendQueue = exports.run = exports.addToQueue = exports.handlers = exports.queueInterval = exports.disabled = exports.queue = void 0;
const builders_1 = require("@discordjs/builders");
const rest_1 = require("@discordjs/rest");
const utils_1 = require("@elara-services/utils");
const v10_1 = require("discord-api-types/v10");
const _1 = require(".");
exports.queue = [];
exports.disabled = [];
exports.queueInterval = null;
exports.handlers = {
    afterWebhookSent: (message) => {
        (0, _1._debug)(`[WEBHOOK:MESSAGE:SENT]: `, message);
        return;
    },
    errorWebhookSend: (error, data) => {
        (0, _1._debug)(`[WEBHOOK:MESSAGE:ERROR]: `, error, data);
        return;
    }
};
function addToQueue(channelId, webhook, opts, threadId) {
    (0, _1._debug)(`Added (${channelId}) to the queue with webhook (${webhook}${threadId ? `?thread_id=${threadId}` : ""})`, opts);
    exports.queue.push({
        channelId,
        webhook,
        opts,
        threadId,
    });
}
exports.addToQueue = addToQueue;
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!exports.queue.length) {
            (0, _1._debug)(`No queue (${exports.queue.length}), ignoring.`);
            return;
        }
        let channels = {};
        for (const que of exports.queue.filter(c => !exports.disabled.includes(c.channelId))) {
            let { channelId, webhook, threadId, opts: { embeds, components, webhook: wb, files, content, allowed_mentions } } = que;
            if (!webhook) {
                (0, _1._debug)(`No 'webhook' url found, ignoring.`);
                continue;
            }
            if (!Array.isArray(embeds)) {
                embeds = [];
            }
            if (!Array.isArray(components)) {
                components = [];
            }
            if (!Array.isArray(files)) {
                files = [];
            }
            if (!embeds.length) {
                (0, _1._debug)(`No embeds found, ignoring.`);
                continue;
            }
            const cName = `${que.webhook}${que.threadId ? `?thread_id=${que.threadId}` : ""}`;
            if (channels[cName]) {
                channels[cName].embeds.push(...embeds);
                channels[cName].components.push(...components);
                if (utils_1.is.string(content) && content !== "undefined") {
                    if (utils_1.is.string(channels[cName].content)) {
                        channels[cName].content = `${channels[cName].content}\n${content}`.slice(0, 2000);
                    }
                    else {
                        channels[cName].content = content;
                    }
                }
            }
            else {
                channels[cName] = { allowed_mentions: allowed_mentions || undefined, content: content || "", channelId, webhook, name: (wb === null || wb === void 0 ? void 0 : wb.name) || "", icon: (wb === null || wb === void 0 ? void 0 : wb.icon) || "", files, embeds, components, threadId };
            }
        }
        exports.queue.length = 0;
        for (const channel of Object.keys(channels)) {
            let ch = channels[channel], [id, token] = ch.webhook.split("/");
            if (!_1.webhooks.has(ch.channelId) || !ch.embeds.length) {
                (0, _1._debug)(`channelId was found in the ignored webhooks collection (${_1.webhooks.has(ch.channelId)}) or there is no embeds (${ch.embeds.length})`);
                delete channels[channel];
                continue;
            }
            delete channels[channel];
            let chunks = (0, utils_1.chunk)(ch.embeds, 10);
            if (!chunks.length) {
                (0, _1._debug)(`No 'chunks' found, ignoring.`);
                continue;
            }
            for (const send of chunks) {
                let res = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    const toJSON = (e) => "toJSON" in e ? e.toJSON() : e;
                    let length = send.map(embed => (0, builders_1.embedLength)(toJSON(embed))).reduce((a, b) => a + b, 0);
                    const sendQ = (embeds) => sendQueue(id, token, {
                        embeds: Array.isArray(embeds) ? embeds.map(c => toJSON(c)) : [toJSON(embeds)],
                        avatarURL: ch.icon,
                        content: ch.content,
                        username: ch.name,
                        files: ch.files,
                        components: Array.isArray(ch.components) ? ch.components.map(c => toJSON(c)) : ch.components,
                        threadId: ch.threadId,
                        channelId: ch.channelId,
                        allowed_mentions: ch.allowed_mentions,
                    });
                    if (length >= 6000) {
                        for (const embed of send) {
                            sendQ(embed);
                        }
                        resolve(true);
                    }
                    else {
                        resolve(yield sendQ(send));
                    }
                }));
                if (!res) {
                    (0, _1._debug)(`'queue.run.res' is false, stopping the entire queue.`);
                    return false;
                }
                continue;
            }
        }
        ;
    });
}
exports.run = run;
function sendQueue(id, token, { embeds, content, username, avatarURL, threadId, components, files, channelId, allowed_mentions }, shouldTransformComponents = true) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield _1.rest.post(v10_1.Routes.webhook(id, token), {
            query: (0, rest_1.makeURLSearchParams)({
                thread_id: threadId,
                wait: true,
            }),
            body: {
                username, avatar_url: avatarURL,
                content: utils_1.is.string(content) && content !== "undefined" ? content : "",
                components: shouldTransformComponents ? (0, _1.getComponents)(components || []) : components || undefined,
                embeds,
                allowed_mentions,
            },
            auth: false,
            files,
        })
            .then((m) => {
            exports.handlers.afterWebhookSent(m);
            return m;
        })
            .catch((e) => {
            if (channelId) {
                (0, _1._debug)(`[WEBHOOK:CACHE:DELETED]: for channelId (${channelId})`);
                _1.webhooks.delete(channelId);
            }
            exports.handlers.errorWebhookSend(e, {
                username,
                avatarURL,
                threadId,
                channelId,
                embeds,
                components,
                files,
                allowed_mentions
            });
            return null;
        });
    });
}
exports.sendQueue = sendQueue;
function startQueue(interval = 6000) {
    if (interval <= 0) {
        (0, _1.throwError)(`You have to provide a interval longer than 0ms`);
    }
    if (exports.queueInterval) {
        clearInterval(exports.queueInterval);
    }
    exports.queueInterval = setInterval(() => run(), interval);
}
exports.startQueue = startQueue;
