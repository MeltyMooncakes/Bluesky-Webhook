"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuildWebhook = void 0;
const rest_1 = require("@discordjs/rest");
const __1 = require("..");
class GuildWebhook {
    constructor(guild) {
        if (!guild) {
            (0, __1.throwError)(`You provided either no guild in the constructor`);
        }
        this.guild = guild;
        this.client = guild.client;
        this.rest = new rest_1.REST()
            .setToken(guild.client.token);
    }
    fetchWebhookInfo(opt) {
        let def = { username: this.guild.name, avatar_url: this.guild.icon ? this.guild.iconURL() : `https://cdn.discordapp.com/emojis/847624594717671476.png` };
        if (opt)
            return { username: (opt === null || opt === void 0 ? void 0 : opt.name) || def.username, avatar_url: (opt === null || opt === void 0 ? void 0 : opt.icon) || def.avatar_url };
        return def;
    }
    fetch(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(channel === null || channel === void 0 ? void 0 : channel.id) || !('fetchWebhooks' in channel)) {
                return null;
            }
            const w = __1.webhooks.get(channel.id);
            if (w) {
                return w;
            }
            const hooks = yield channel.fetchWebhooks().catch(() => null);
            let hook = null;
            if (hooks === null || hooks === void 0 ? void 0 : hooks.size) {
                hook = hooks.find(c => { var _a; return ((_a = c.owner) === null || _a === void 0 ? void 0 : _a.id) === this.client.user.id && c.token; });
            }
            if (!hook) {
                hook = yield (0, __1.createWebhook)(this.rest, channel.id, `${this.client.user.username} Services`);
            }
            if (!hook || !hook.token) {
                return null;
            }
            const data = { id: hook.id, token: hook.token };
            __1.webhooks.set(channel.id, data);
            return data;
        });
    }
    send(channelId, opt, queue = true, shouldTransformComponents = true) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!channelId || !this.disabled) {
                return (0, __1._debug)(`No channelId provided (${channelId}) or 'this.disabled' is false (${this.disabled})`);
            }
            let channel = this.guild.channels.resolve(channelId);
            if (!channel) {
                return (0, __1._debug)(`No guild channel found for: ${channelId}`);
            }
            let { content, embeds, username, avatar_url: avatarURL, files, components, allowed_mentions } = Object.assign(Object.assign({}, this.fetchWebhookInfo(opt.webhook)), { embeds: (opt.embeds && Array.isArray(opt.embeds)) ? opt.embeds : [], content: (_a = opt.content) !== null && _a !== void 0 ? _a : null, components: (_b = opt.components) !== null && _b !== void 0 ? _b : [], files: (_c = opt.files) !== null && _c !== void 0 ? _c : undefined, allowed_mentions: opt.allowed_mentions || undefined });
            const inc = (arr, includes) => arr.some(c => includes ? username.toLowerCase().includes(c) : username.toLowerCase() === c);
            if (inc(__1.bannedUsernames.includes, true) || inc(__1.bannedUsernames.equals, false)) {
                username = this.client.user.username;
                avatarURL = this.client.user.displayAvatarURL();
            }
            if (!avatarURL) {
                avatarURL = "";
            }
            if (!content && !embeds.length) {
                return (0, __1._debug)(`No content (${(content === null || content === void 0 ? void 0 : content.length) || 0}), or no embeds (${embeds.length || 0})`);
            }
            let threadId;
            if (channel.isThread() || ["GUILD_FORUM", "GuildForum", 15].includes(channel.type)) {
                let parent = channel.parent;
                if (parent) {
                    threadId = channel.id;
                    channel = parent;
                }
                else if (channel.parentId) {
                    const p = this.guild.channels.resolve(channel.parentId) || (yield this.guild.channels.fetch(channel.parentId, { cache: true }).catch(() => { }));
                    if (p) {
                        threadId = channel.id;
                        channel = p;
                    }
                }
            }
            const hook = yield this.fetch(channel);
            if (!hook) {
                return (0, __1._debug)(`No 'hook' found`);
            }
            if (queue === true) {
                return (0, __1.addToQueue)(channel.id, `${hook.id}/${hook.token}`, {
                    embeds, components, files, webhook: { name: username, icon: avatarURL }, allowed_mentions,
                    content,
                }, threadId);
            }
            return (0, __1.sendQueue)(hook.id, hook.token, {
                embeds, components,
                threadId,
                username,
                files,
                avatarURL,
                channelId,
                content,
                allowed_mentions
            }, shouldTransformComponents);
        });
    }
    get disabled() {
        if (!this.guild || !this.guild.available || __1.disabledLogging.includes(this.guild.id)) {
            return false;
        }
        return true;
    }
}
exports.GuildWebhook = GuildWebhook;
