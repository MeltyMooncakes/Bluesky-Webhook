"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = exports.defaultWebhookOptions = void 0;
const rest_1 = require("@discordjs/rest");
const utils_1 = require("@elara-services/utils");
const v10_1 = require("discord-api-types/v10");
const __1 = require("..");
exports.defaultWebhookOptions = {
    username: "Webhook",
    avatar_url: "https://cdn.discordapp.com/emojis/1059556038761787433.png"
};
class Webhook {
    constructor(botToken) {
        if (!botToken || typeof botToken !== "string") {
            (0, __1.throwError)(`You provided either no botToken in the constructor or it's not a string.`);
        }
        this.clientId = (0, utils_1.getClientIdFromToken)(botToken);
        if (!this.clientId || typeof this.clientId !== "string") {
            (0, __1.throwError)(`You didn't provide a valid botToken.`);
        }
        this.rest = new rest_1.REST()
            .setToken(botToken);
    }
    fetchWebhookInfo(opt) {
        return {
            username: (opt === null || opt === void 0 ? void 0 : opt.name) || exports.defaultWebhookOptions.username,
            avatar_url: (opt === null || opt === void 0 ? void 0 : opt.icon) || exports.defaultWebhookOptions.avatar_url
        };
    }
    fetch(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!channelId) {
                return null;
            }
            const w = __1.webhooks.get(channelId);
            if (w) {
                return w;
            }
            const hooks = yield this.rest.get(v10_1.Routes.channelWebhooks(channelId)).catch(() => null);
            let hook = null;
            if (Array.isArray(hooks) && hooks.length) {
                hook = hooks.find(c => { var _a; return ((_a = c.user) === null || _a === void 0 ? void 0 : _a.id) === this.clientId && c.token; });
            }
            if (!hook) {
                hook = yield (0, __1.createWebhook)(this.rest, channelId, exports.defaultWebhookOptions.username);
            }
            if (!hook || !hook.token) {
                return null;
            }
            const data = {
                id: hook.id,
                token: hook.token,
            };
            __1.webhooks.set(channelId, data);
            return data;
        });
    }
    send(channelId, opt, queue = true, shouldTransformComponents = true) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!channelId) {
                return (0, __1._debug)(`No channelId provided`, channelId);
            }
            const channel = yield this.fetchChannel(channelId);
            if (!channel) {
                return (0, __1._debug)(`No 'channel' found`, channelId);
            }
            if (channel.guildId && __1.disabledLogging.includes(channel.guildId)) {
                return (0, __1._debug)(`'channel.guildId' (${channel.guildId}) is ignored`, __1.disabledLogging.includes(channel.guildId));
            }
            let finalChannelId = channelId;
            let { content, embeds, username, avatar_url: avatarURL, files, components, allowed_mentions } = Object.assign(Object.assign({}, this.fetchWebhookInfo(opt.webhook)), { embeds: (opt.embeds && Array.isArray(opt.embeds)) ? opt.embeds : [], content: (_a = opt.content) !== null && _a !== void 0 ? _a : null, components: (_b = opt.components) !== null && _b !== void 0 ? _b : [], files: (_c = opt.files) !== null && _c !== void 0 ? _c : undefined, allowed_mentions: opt.allowed_mentions || undefined });
            const inc = (arr, includes) => arr.some(c => includes ? username.toLowerCase().includes(c) : username.toLowerCase() === c);
            if (inc(__1.bannedUsernames.includes, true) || inc(__1.bannedUsernames.equals, false)) {
                username = exports.defaultWebhookOptions.username;
                avatarURL = exports.defaultWebhookOptions.avatar_url;
            }
            if (!avatarURL) {
                avatarURL = "";
            }
            if (!content && !embeds.length) {
                return (0, __1._debug)(`No content (${(content === null || content === void 0 ? void 0 : content.length) || 0}) or no embeds (${embeds.length || 0})`);
            }
            let threadId;
            if (channel.parentId && [10, 11, 12, 15, 16].includes(channel.type)) {
                threadId = channelId;
                finalChannelId = channel.parentId;
            }
            const hook = yield this.fetch(finalChannelId);
            if (!hook) {
                return (0, __1._debug)(`No 'hook' found`, hook);
            }
            if (queue === true) {
                return (0, __1.addToQueue)(finalChannelId, `${hook.id}/${hook.token}`, {
                    embeds, components, content, webhook: { name: username, icon: avatarURL }, files, allowed_mentions,
                }, threadId);
            }
            return (0, __1.sendQueue)(hook.id, hook.token, {
                embeds, components,
                files,
                threadId,
                username,
                content,
                avatarURL,
                channelId,
                allowed_mentions,
            }, shouldTransformComponents);
        });
    }
    fetchChannel(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const channel = __1.channels.get(channelId);
            if (channel) {
                if (channel.invalid) {
                    (0, __1._debug)(`'fetchChannel' the 'channel' is invalid, ignoring`);
                    return null;
                }
                return channel;
            }
            const res = yield this.rest.get(v10_1.Routes.channel(channelId)).catch((e) => e);
            if (!res || res instanceof Error) {
                __1.channels.set(channelId, { id: channelId, invalid: true, type: 0 });
                (0, __1._debug)(`ChannelId (${channelId}) had an error while fetching`, res);
                return null;
            }
            let data = {
                id: channelId,
                invalid: false,
                type: res.type,
            };
            if ('guild_id' in res) {
                data.guildId = res.guild_id;
            }
            if ("parent_id" in res) {
                data.parentId = res.parent_id;
            }
            __1.channels.set(channelId, data);
            return data;
        });
    }
}
exports.Webhook = Webhook;
