"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscordWebhook = void 0;
const rest_1 = require("@discordjs/rest");
const utils_1 = require("@elara-services/utils");
const utils_2 = require("./utils");
const rest = new rest_1.REST();
class DiscordWebhook {
    constructor(url, options = utils_2.defaultOptions) {
        if (!(0, utils_2.validateURL)(url)) {
            (0, utils_2.error)(`You didn't provide any webhook url or you provided an invalid webhook url`);
        }
        this.url = url;
        if (typeof options !== "object") {
            options = utils_2.defaultOptions;
        }
        ;
        this.data = {
            username: options.username || undefined,
            avatar_url: options.avatar_url || undefined,
            embeds: [],
            content: undefined,
            components: [],
            thread_id: options.threadId || undefined,
            allowed_mentions: undefined,
        };
    }
    setAllowedMentions(opt) {
        this.data.allowed_mentions = opt;
        return this;
    }
    field(name = "\u200b", value = "\u200b", inline = false) {
        return (0, utils_1.field)(name, value, inline);
    }
    author(username = "", avatar = "") {
        if (utils_1.is.string(username) && username.length >= 2) {
            this.data.username = username;
        }
        if (utils_1.is.string(avatar) && avatar.match(/https?:\/\//gi)) {
            this.data.avatar_url = avatar;
        }
        ;
        return this;
    }
    ;
    mention(text = "") {
        if (utils_1.is.string(text) && text.match(/<@(!|&)?/gi)) {
            this.data.content = `${text}${this.data.content ? `, ${this.data.content}` : ""}`;
        }
        return this;
    }
    ;
    content(text = "") {
        if (!utils_1.is.string(text)) {
            return this;
        }
        if (text.length > utils_1.limits.content) {
            text = text.slice(0, utils_1.limits.content);
        }
        if (this.data.content) {
            this.data.content = this.data.content += text;
        }
        else {
            this.data.content = text;
        }
        return this;
    }
    ;
    embed(embed) {
        if (this.data.embeds.length > 10) {
            return this;
        }
        if ("color" in embed && utils_1.is.string(embed.color)) {
            embed.color = (0, utils_1.resolveColor)(embed.color);
        }
        ;
        this.data.embeds.push(embed);
        return this;
    }
    ;
    embeds(embeds = []) {
        for (const embed of embeds) {
            this.embed(embed);
        }
        return this;
    }
    ;
    button(data) {
        this.data.components.push(data);
        return this;
    }
    ;
    buttons(components = []) {
        for (const component of components) {
            this.button(component);
        }
        return this;
    }
    ;
    send(force = false, token = "") {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (token) {
                rest.setToken(token);
            }
            if (!this.data.content && !this.data.embeds.length && !this.data.components.length)
                return (0, utils_2.error)(`You didn't add anything to be sent.`);
            const Url = (0, utils_2.url)(this.url);
            if (!Url) {
                return;
            }
            let r = yield rest.post(`/${Url.path}`, {
                auth: false,
                body: this.data,
                query: (0, rest_1.makeURLSearchParams)({
                    wait: true,
                    thread_id: this.data.thread_id || Url.thread_id
                })
            })
                .then(r => (0, utils_2.status)(true, r))
                .catch(e => (0, utils_2.error)(e));
            if (!(r === null || r === void 0 ? void 0 : r.status)) {
                (0, utils_2.error)((r === null || r === void 0 ? void 0 : r.data) || "Unknown Issue while sending");
            }
            return (_a = r === null || r === void 0 ? void 0 : r.data) !== null && _a !== void 0 ? _a : null;
        });
    }
    edit(messageId = "") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!utils_1.is.string(messageId)) {
                (0, utils_2.error)(`You didn't provide a message ID.`);
                return;
            }
            if (!this.data.content && !this.data.embeds.length && !this.data.components.length)
                return (0, utils_2.error)(`You didn't add anything to be sent.`);
            const Url = (0, utils_2.url)(this.url);
            if (!Url || !Url.path) {
                (0, utils_2.error)(`You didn't provide a valid webhook?`);
                return;
            }
            return yield rest.patch(`/${Url.path}/messages/${messageId}`, {
                body: this.data,
                auth: false,
                query: (0, rest_1.makeURLSearchParams)({
                    wait: true,
                    thread_id: this.data.thread_id || Url.thread_id
                })
            })
                .then(r => (0, utils_2.status)(true, r))
                .catch(e => (0, utils_2.error)(e));
        });
    }
}
exports.DiscordWebhook = DiscordWebhook;
