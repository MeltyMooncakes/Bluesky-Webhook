"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SDK_key, _SDK_baseURL;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK = void 0;
const fetch_1 = require("@elara-services/fetch");
const utils_1 = require("./utils");
__exportStar(require("./interfaces"), exports);
class SDK {
    constructor(key, baseURL) {
        _SDK_key.set(this, "");
        _SDK_baseURL.set(this, utils_1.links.base);
        if (key) {
            if (typeof key !== "string") {
                throw new Error(`The API key you provided isn't a string!`);
            }
            __classPrivateFieldSet(this, _SDK_key, key, "f");
        }
        if (baseURL) {
            __classPrivateFieldSet(this, _SDK_baseURL, baseURL, "f");
        }
    }
    get support() {
        return utils_1.links.support;
    }
    get docs() {
        return utils_1.links.docs;
    }
    async fetch(url, send, useKey = true, useBase = true, key = __classPrivateFieldGet(this, _SDK_key, "f")) {
        try {
            const res = await (0, fetch_1.fetch)(`${useBase ? __classPrivateFieldGet(this, _SDK_baseURL, "f") : ""}${url}`)
                .header({
                key: useKey ? key || __classPrivateFieldGet(this, _SDK_key, "f") : "",
                "User-Agent": utils_1.userAgent,
                Authorization: useKey ? key || __classPrivateFieldGet(this, _SDK_key, "f") : "",
            })
                .body(send, "json")
                .send();
            return res.json();
        }
        catch (err) {
            console.log(err);
            return null;
        }
    }
    async ping() {
        const res = await this.fetch(utils_1.routes.ping);
        return res ?? (0, utils_1.status)(`I was unable to fetch the site ping.`);
    }
    get haste() {
        return {
            get: async (id, url = utils_1.links.haste, key) => {
                try {
                    if (!id) {
                        return (0, utils_1.status)(`You didn't provide a paste ID!`);
                    }
                    const body = await this.fetch(`${url}/documents/${id}`, undefined, key ? true : false, false, key);
                    if (!body) {
                        return (0, utils_1.status)(`No response from the hastebin website.`);
                    }
                    return {
                        status: true,
                        id: body.key,
                        key: body.key,
                        content: body.data,
                        url: `${url}/${body.key}`,
                    };
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            post: async (content, options = {}, key) => {
                try {
                    if (typeof options === "string") {
                        options = {
                            url: utils_1.links.haste,
                            extension: options,
                        };
                    }
                    const url = "url" in options ? options.url : utils_1.links.haste;
                    const extension = "extension" in options ? options.extension : "js";
                    if (!content) {
                        return (0, utils_1.status)(`You didn't provide any content!`);
                    }
                    const res = await (0, fetch_1.fetch)(`${url}/documents`, "POST")
                        .header("User-Agent", utils_1.userAgent)
                        .header("Authorization", key || "")
                        .header("Content-Type", "text/plain")
                        .body(content, "text")
                        .send()
                        .catch(() => ({ statusCode: 500, json: () => null }));
                    if (res.statusCode !== 200) {
                        return (0, utils_1.status)(`No response from the hastebin website.`);
                    }
                    const body = res.json();
                    if (!body) {
                        throw new Error(`Unable to create a new haste document.`);
                    }
                    return {
                        status: true,
                        id: body.key,
                        url: `${url}/${body.key}${extension ? `.${extension}` : ""}`,
                    };
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
        };
    }
    get paste() {
        return {
            get: async (id) => {
                try {
                    if (!id) {
                        return (0, utils_1.status)(`You didn't provide a paste ID.`);
                    }
                    const res = await this.fetch(utils_1.routes.bin.get(id));
                    return res ?? (0, utils_1.status)(`No response from the Pastebin API`);
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            post: async (title, content, privatePaste = false) => {
                try {
                    if (!content) {
                        return (0, utils_1.status)(`You didn't provide any content to post to the pastebin API`);
                    }
                    if (typeof privatePaste !== "boolean") {
                        privatePaste = false;
                    }
                    const res = await (0, fetch_1.fetch)(`${__classPrivateFieldGet(this, _SDK_baseURL, "f")}${utils_1.routes.bin.post}`, "POST")
                        .header({
                        key: __classPrivateFieldGet(this, _SDK_key, "f"),
                        "User-Agent": utils_1.userAgent,
                    })
                        .body({
                        content,
                        title,
                        priv: privatePaste,
                    }, "json")
                        .send()
                        .catch(() => ({ statusCode: 500, json: () => null }));
                    if (res.statusCode !== 200) {
                        return (0, utils_1.status)(`No response from the pastebin.`);
                    }
                    const body = res.json();
                    if (!body) {
                        return (0, utils_1.status)(`No response from the Pastebin API!`);
                    }
                    return body;
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
        };
    }
    get api() {
        return {
            dbl: {
                get: async (token, id) => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a Discord Bot List(top.gg) token!`);
                        }
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a Discord Bot or User ID`);
                        }
                        const res = await this.fetch(utils_1.routes.dbl.get(token, id));
                        return (res ??
                            (0, utils_1.status)(`Unknown error while trying to fetch the image from the API`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                post: async (token, id, servers, shards = 0) => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a Discord Bot List(top.gg) token!`);
                        }
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a Discord Bot or User ID`);
                        }
                        if (!servers) {
                            return (0, utils_1.status)(`You didn't provide 'servers' number!`);
                        }
                        if (isNaN(servers)) {
                            return (0, utils_1.status)(`The 'servers' number value isn't valid!`);
                        }
                        if (isNaN(shards)) {
                            return (0, utils_1.status)(`The 'shards' number value isn't valid!`);
                        }
                        const res = await this.fetch(utils_1.routes.dbl.post(token, id, shards, servers));
                        return (res ??
                            (0, utils_1.status)(`Unknown error while trying to post the stats to DBL(top.gg)`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
            },
            lyrics: async (name) => {
                try {
                    const res = await this.fetch(utils_1.routes.api.lyrics(name));
                    return res ?? (0, utils_1.status)(`No response from the lyrics API.`);
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            photos: async (image) => {
                try {
                    if (!image) {
                        return (0, utils_1.status)(`You didn't provide an image endpoint, ex: 'cats', 'pugs', 'dogs'`);
                    }
                    const res = await this.fetch(utils_1.routes.api.photos(image));
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the image from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            math: async (problem) => {
                try {
                    if (!problem) {
                        return (0, utils_1.status)(`You didn't provide a math problem`);
                    }
                    const res = await this.fetch(utils_1.routes.api.math, { problem });
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the math problem from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            special: async (image) => {
                try {
                    if (!image) {
                        return (0, utils_1.status)(`You didn't provide an special endpoint`);
                    }
                    const res = await this.fetch(utils_1.routes.api.special(image));
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the image from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            translate: async (to, text) => {
                try {
                    if (!to) {
                        return (0, utils_1.status)(`You didn't provide the 'to' language!`);
                    }
                    if (!text) {
                        return (0, utils_1.status)(`You didn't provide any text!`);
                    }
                    const res = await this.fetch(utils_1.routes.api.translate, {
                        to,
                        text,
                    });
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the translation from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            facts: async (type = "random") => {
                try {
                    const res = await this.fetch(utils_1.routes.api.facts(type));
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the fact(s) from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            memes: async (clean = false) => {
                try {
                    if (![true, false].includes(clean)) {
                        return (0, utils_1.status)(`The 'clean' you provided is invalid, it has to be a boolean.`);
                    }
                    const res = await this.fetch(utils_1.routes.api.memes(clean));
                    return res ?? (0, utils_1.status)(`I was unable to fetch the meme :(`);
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            ball: async () => {
                try {
                    const res = await this.fetch(utils_1.routes.api.ball);
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch 8ball from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            npm: async (name) => {
                try {
                    if (!name) {
                        return (0, utils_1.status)(`You didn't provide a npm package name!`);
                    }
                    const res = await this.fetch(utils_1.routes.api.npm(name));
                    return (res ??
                        (0, utils_1.status)(`Unable to fetch the npm package from the API site!`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            time: async (place, all = false) => {
                try {
                    if (typeof all !== "boolean") {
                        return (0, utils_1.status)(`'all' isn't a boolean!`);
                    }
                    if (all === true) {
                        const res = await this.fetch(utils_1.routes.api.time.all);
                        return res ?? (0, utils_1.status)(`Unable to fetch the times list!`);
                    }
                    if (!place) {
                        return (0, utils_1.status)(`You didn't provide a place!`);
                    }
                    const res = await this.fetch(utils_1.routes.api.time.place(place));
                    return (res ?? (0, utils_1.status)(`Unable to fetch the info for ${place}`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            docs: async (search, project = "stable", branch = "stable") => {
                try {
                    if (!search) {
                        return (0, utils_1.status)(`Well tell me what you want to search for?`);
                    }
                    const res = await this.fetch(utils_1.routes.api.docs(search, project, branch));
                    return (res ??
                        (0, utils_1.status)(`I was unable to fetch the docs infomration`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            platform: {
                ytstats: async (token, IDOrName) => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a youtube API key`);
                        }
                        if (!IDOrName) {
                            return (0, utils_1.status)(`You didnt provide a channel ID or name!`);
                        }
                        const res = await this.fetch(utils_1.routes.platform.ytstats(IDOrName, token));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the ytstats information from the API site`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                roblox: async (id) => {
                    try {
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a Discord user ID`);
                        }
                        const res = await this.fetch(utils_1.routes.platform.roblox(id, false));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the roblox information from the API site`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                robloxgroup: async (id) => {
                    try {
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a roblox group ID`);
                        }
                        const res = await this.fetch(utils_1.routes.platform.roblox(id, true));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the roblox group information from the API site`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                fortnite: async (token, name, platform = "pc") => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a Fortnite API key`);
                        }
                        if (!name) {
                            return (0, utils_1.status)(`You didn't provide a username!`);
                        }
                        if (!platform) {
                            platform = "pc";
                        }
                        const res = await this.fetch(utils_1.routes.platform.fortnite(name, token, platform));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the fortnite information from the API site`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                imdb: async (token, show) => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a 'imdb' API key!`);
                        }
                        if (!show) {
                            return (0, utils_1.status)(`You didn't provide the tv-show or movie name!`);
                        }
                        const res = await this.fetch(utils_1.routes.platform.imdb(show, token));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the imdb information, try again later.`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                ytsearch: async (token, name, type = "video") => {
                    try {
                        if (!token) {
                            return (0, utils_1.status)(`You didn't provide a 'imdb' API key!`);
                        }
                        if (!name) {
                            return (0, utils_1.status)(`You didn't provide the name to search for!`);
                        }
                        if (!type) {
                            type = "video";
                        }
                        const res = await this.fetch(utils_1.routes.platform.ytsearch(name, type, token));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the ytsearch information, try again later.`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
                picarto: async (nameOrID) => {
                    try {
                        if (!nameOrID) {
                            return (0, utils_1.status)(`You didn't provide a Picarto ID or name`);
                        }
                        const res = await this.fetch(utils_1.routes.platform.picarto(nameOrID));
                        return (res ??
                            (0, utils_1.status)(`Unable to fetch the Picarto information, try again later.`));
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                },
            },
        };
    }
    get automod() {
        return {
            images: async (token, urls = [], percent = 89) => {
                try {
                    if (!token) {
                        return (0, utils_1.status)(`You didn't provide a moderatecontent API Key!`);
                    }
                    if (!Array.isArray(urls)) {
                        return (0, utils_1.status)(`The "urls" you provided wasn't an array!`);
                    }
                    if (!urls.length) {
                        return (0, utils_1.status)(`You didn't provide images to check!`);
                    }
                    const res = await this.fetch(utils_1.routes.automod.images(token, percent), { images: urls });
                    return (res ??
                        (0, utils_1.status)(`Unknown error while trying to fetch the imagemod information from the API`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            words: async (message, words = [], emojis = []) => {
                try {
                    if (!message || !message.toString().length) {
                        return (0, utils_1.status)(`You didn't provide a message`);
                    }
                    const res = await this.fetch(utils_1.routes.automod.words, {
                        message,
                        words,
                        emojis,
                    });
                    return (res ?? (0, utils_1.status)(`I was unable to fetch the API response`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
            links: async (message, options = {
                prefix: null,
                regexp: true,
            }) => {
                try {
                    if (!message || !message.toString().length) {
                        return (0, utils_1.status)(`You didn't provide a message.`);
                    }
                    const res = await this.fetch(utils_1.routes.automod.links, {
                        message,
                        regexp: options.regexp,
                        prefix: options.prefix,
                    });
                    return (res ?? (0, utils_1.status)(`I was unable to fetch the API response`));
                }
                catch (err) {
                    return (0, utils_1.status)(err);
                }
            },
        };
    }
    get dev() {
        return {
            blacklists: {
                servers: async (id = "all", type = "list", data = { name: "", reason: "", mod: "" }) => {
                    try {
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a Discord server ID!`);
                        }
                        switch (type.toLowerCase()) {
                            case "add": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.servers.toggle({
                                    id,
                                    action: type,
                                    ...data,
                                }));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to add the server to the blacklisted database!`));
                            }
                            case "delete":
                            case "remove": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.servers.toggle({
                                    id,
                                    action: type,
                                    ...data,
                                }));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to remove the server to the blacklisted database!`));
                            }
                            case "list": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.servers.list(id));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to fetch the blacklisted servers.`));
                            }
                        }
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                    return (0, utils_1.status)(`You provided an invalid type.`);
                },
                users: async (id = "all", type = "list", data = { username: "", tag: "", reason: "", mod: "" }) => {
                    try {
                        if (!id) {
                            return (0, utils_1.status)(`You didn't provide a Discord user ID!`);
                        }
                        switch (type.toLowerCase()) {
                            case "add": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.users.toggle({
                                    id,
                                    action: "add",
                                    ...data,
                                }));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to add the user to the blacklisted database!`));
                            }
                            case "delete":
                            case "remove": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.users.toggle({
                                    id,
                                    action: "remove",
                                    ...data,
                                }));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to remove the user to the blacklisted database!`));
                            }
                            case "list": {
                                const res = await this.fetch(utils_1.routes.dev.blacklist.users.list(id));
                                return (res ??
                                    (0, utils_1.status)(`I was unable to fetch the blacklisted users.`));
                            }
                        }
                    }
                    catch (err) {
                        return (0, utils_1.status)(err);
                    }
                    return (0, utils_1.status)(`You provided an invalid type.`);
                },
            },
        };
    }
}
exports.SDK = SDK;
_SDK_key = new WeakMap(), _SDK_baseURL = new WeakMap();
